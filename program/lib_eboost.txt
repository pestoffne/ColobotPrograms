public class RadarArgs {
	int[] cat;
	float angle;
	float focus;
	float min;
	float max;
	float sens;
	int filter;
	
	void RadarArgs(int[] cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		this.cat = cat;
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
	
	void RadarArgs(int cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		EBoost e(null);
		
		this.cat = e.to_list(cat);
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
}

public class EBoost {
	object actor;
	static string logfile = "common_logs.txt";
	
	void EBoost(object actor) {
		this.actor = actor;
		errmode(0);
	}
	
	int another_team() {
		return 3 - actor.team;
	}
	
	object assert(bool value, string text="assertion error") {
		if (value) {
			return retobject(0);
		}
		
		message(text, DisplayError);
		return null;
	}
	
	object assert_equal(float a, float b) {
		return assert(a == b, "assert(" + a + " == " + b + ") failed");
	}
	
	bool can_load(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber
		or cat == Subber
		or cat == Me
		or cat == AlienWasp;
	}
	
	bool can_switch_own_cell(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber;
	}
	
	float _get_energy_level(object item) {
		if (item.category == PowerCell) {
			return item.energyLevel;
		}
		
		if (item.category == NuclearCell) {
			return item.energyLevel * 10;
		}
		
		assert(false, "_get_energy_level of non cell").id;
		return 0;  // never executes
	}
	
	int check_energy(float need_energy=0.33) {
		// Charge methods priorities
		// 1) Goto PowerStation [only PowerCell]
		// 2) Goto switch cell  [only Grabbers]
		// 3) Goto PowerCaptor  [only PowerCell]
		// 4) Ask for help
		object item;
		
		if (actor.energyCell == null
		            or actor.energyCell.category != PowerCell
		           and actor.energyCell.category != NuclearCell) {
			return 1;
		}
		
		if (_get_energy_level(actor.energyCell) >= need_energy) {
			return 0;  // Energy level is already ok
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station() == 0) {
				return 0;
			}
		}
		
		if (can_switch_own_cell(actor.category)) {
			if (go_switch_cell() == 0) {
				return 0;
			}
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station(PowerCaptor, 180.0) == 0) {
				return 0;
			}
		}
		
		return 1;
	}
	
	void check_energy_loop(float need_energy=0.33) {
		bool first;
		
		first = true;
		
		for (;;) {
			if (check_energy(need_energy) == 0) {
				return;
			}
			
			if (first) {
				message("I need help with charge", DisplayWarning);
			}
			
			wait(1);
			first = false;
		}
	}
	
	int check_shield(float need_shield=0.5) {
		object item;
		
		if (actor.shieldLevel >= need_shield) {
			return 0;
		}
		
		return go_repair();
	}
	
	bool contains(int[] list, int value) {
		for (int i = 0; i < sizeof(list); ++i) {
			if (list[i] == value) {
				return true;
			}
		}
		
		return false;
	}
	
	void dock_to_ship() {
		point ship_pos; point[] slots; point slot; int i;
		
		ship_pos = radar(SpaceShip).position;
		
		// create list of slots. better to do it staticaly
		i = 0;
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 4.0, 150);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 4.0,  30);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 4.0,  90);
		
		for (i = 0; i < sizeof(slots); ++i) {
			slot = slots[i];
			
			if (search(Any, slot, 0, 1.3) == null) {
				goto_p(slot, 2);
				move(0.5);
				
				if (drop() == 0) {
					break;
				}
			}
		}
	}
	
	bool _helix_helper(point pos) {
		object item;
		
		item = search(Any, pos, 0, 1.7);
		
		if (item != null and not is_label(item.category)) {
			return false;
		}
		
		for (int i = 0; i < 4; ++i) {
			if (goto_p(pos) == 0 and drop() == 0) {
				return true;
			}
			
			pos.z += 90;
		}
		
		return false;
	}
	
	void drop_to_helix(point p) {
		int s;
		
		s = 2;
		p.z = 270;  // angle
		
		for (int l = 1; l <= 7; ++l) {
			for (int i = 0; i < l; ++i) {
				if (_helix_helper(p)) {
					return;
				}
				
				p.x += s;
			}
			
			s *= -1;
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
			
			for (int i = 0; i < l; ++i) {
				if (_helix_helper(p)) {
					return;
				}
				
				p.y += s;
			}
			
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
		}
	}
	
	point fire_position(object item) {
		point pos;
		
		pos = item.position;
		
		if (item.category == PowerStation or item.category == Converter) {
			pos.x -= cos(item.orientation) * 2.5;
			pos.y -= sin(item.orientation) * 2.5;
		}
		
		return pos;
	}
	
	float get_height(int cat) {
		float h;
		
		if (cat == Derrick) { h = 35;
		} else if (cat == BotFactory) { h = 28;
		} else if (cat == RepairCenter) { h = 30;
		} else if (cat == PowerStation) { h = 13;
		} else if (cat == Converter) { h = 20;
		} else if (cat == DefenseTower) { h = 30;
		} else if (cat == ResearchCenter) { h = 22;
		} else if (cat == RadarStation) { h = 19;
		} else if (cat == PowerPlant) { h = 20;
		} else if (cat == AutoLab) { h = 16;
		} else if (cat == NuclearPlant) { h = 40;
		} else if (cat == ExchangePost) { h = 19;
		} else {
			return 1.5;  // Assume it is Bot
		}
		
		return h * 0.25;
	}
	
	// return 0 -- PowerCell was recharged
	//        1 -- failed to recharge on PowerStation
	int go_power_station(int cat=PowerStation, float wait_time=15.5) {
		object item;
		
		for (;;) {
			item = radar(cat);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				} else {
					motor(0, 0);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(cat, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.energyCell == null or actor.energyCell.category != PowerCell) {
					return 1;
				}
				
				if (actor.energyCell.energyLevel > 0.95) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_repair() {
		object item; float wait_time;
		
		for (;;) {
			item = radar(RepairCenter);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			wait_time = 15.5;
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(RepairCenter, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.shieldLevel >= 1) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_switch_cell() {
		object item;
		
		if (not can_switch_own_cell(actor.category)) {
			return 1;
		}
		
		item = radar_best_cell(0, 360, 0, 50);
		
		if (item == null) {
			return 1;
		}
		
		goto(item.position);
		switch_cell();
		return 0;
	}
	
	int goto_grab(int cat) {  // TODO: grab from slots
		if (goto_radar_position(new RadarArgs(cat)) != 0) {
			log("warning goto_grab (cat = " + cat + ") failed on step 1 -- goto_radar_position");
			return 1;
		}
		
		if (grab_from_ground(cat) != 0) {
			log("warning goto_grab (cat = " + cat + ") failed on step 2 -- grab_from_ground");
			return 1;
		}
		
		log("info goto_grab ok");
		return 0;
	}
	
	int goto_o(point pos, float dist=1.5) {
		return goto_pp(pos, inverse_direction(pos), dist);
	}
	
	int goto_p(point pos, float dist=1.5) {
		return goto_pp(pos, pos.z, dist);
	}
	
	int goto_pp(point pos, float direct, float dist=1.5) {
		float dist_to_pos;
		
		pos.x -= cos(direct) * dist;
		pos.y -= sin(direct) * dist;
		log("info goto_pp (pos = " + pos.x + ";" + pos.y + ")");
		
		if (distance2d(actor.position, pos) >= 8.0) {
			goto(pos);
		}
		
		dist_to_pos = distance2d(actor.position, pos);
		
		if (dist_to_pos > 0.1 and dist_to_pos < 10.0) {
			goto_straight(pos, 0);  // to more precise position
		}
		
		if (distance2d(actor.position, pos) >= 0.5) {
			log("warning goto_pp failed (distance = " + dist_to_pos + ")");
			return 1;
		}
		
		orient(direct);
		log("info goto_pp ok");
		return 0;
	}
	
	int goto_8(point pos) {
		/*float angle;
		
		angle = inverse_direction(pos);
		
		for (int i = 0; i < 7; ++i) {
			if (goto_pp(pos, normalize_angle(angle + 45 * i), 2) == 0)  {
				move(0.5);
				log("info goto_8 (pos = " + pos.x + ";" + pos.y + ") ok");
				return 0;
			}
		}
		
		log("info goto_8 (pos = " + pos.x + ";" + pos.y + ") ok");
		return 1;*/
		return goto_o(pos);
	}
	
	int goto_radar_item_position(RadarArgs a, bool grab_ground=true, bool grab_slots=true, bool grab_load=false) {
		object item; float angle;
		
		item = radar_item(a, grab_ground, grab_slots, grab_load);
		
		if (item == null) {
			log("warning goto_radar_item_position item does not found");
			return 1;
		}
		
		// TODO: use correct orientation to grab from slot
		return goto_8(item.position);
	}
	
	int goto_radar_position(RadarArgs a) {
		object item;
		
		log("info goto_radar_position run");
		item = radar_(a);
		
		if (item == null) {
			log("warning goto_radar_position item does not found");
			return 1;
		}
		
		if (goto_8(item.position) != 0) {
			log("warning goto_radar_position failed on goto_8");
			return 1;
		}
		
		log("info goto_radar_position ok");
		return 0;
	}
	
	void goto_straight(point pos, float dist=1.5) {
		turn(direction(pos));
		move(distance2d(pos, actor.position) - dist);
	}
	
	void _drop_out() {
		point pos;
		
		pos = actor.position;
		pos.z = actor.orientation;
		goto(space(actor.position, 3));
		drop();
		goto_p(pos);
	}
	
	int grab_from_ground(int cat, int oper=InFront, float min_energy=-1, float max_energy=1) {
		float max_wait; RadarArgs radar_args;
		
		log("info grab_from_ground (cat = " + cat + ") run");
		
		for (int retries = 3; retries >= 0; --retries) {
			if (actor.load == null) {
				break;
			}
			
			if (actor.load.category == cat and actor.load.energyLevel >= min_energy
			                               and actor.load.energyLevel <= max_energy) {
				log("warning grab_from_ground needed item is already loaded before grab");
				return 0;
			}
			
			log("warning grab_from_ground another item is already loaded before grab");
			_drop_out();
		}
		
		radar_args = new RadarArgs(cat, 0, 30, 0, 6);
		
		if (oper == Behind) {
			radar_args.angle = 180;
		}
		
		for (int retries = 3; retries >= 0; --retries) {
			if (radar_wait(radar_args) == null) {
				break;
			}
			
			grab(oper);
			
			if (actor.load == null) {
				wait(0.5);
				continue;
			} else {
				if (actor.load.category == cat and actor.load.energyLevel >= min_energy and actor.load.energyLevel <= max_energy) {
					log("info grab_from_ground (cat = " + cat + ") ok");
					return 0;
				}
			}
			
			log("warning grab_from_ground another item is loaded after grab");
			_drop_out();
		}
		
		log("warning grab_from_ground can not find expected object in front -- timeout expired");
		return 1;
	}
	
	point grab_position(float dist=1.5) {
		point pos;
		
		pos.x = actor.position.x + cos(actor.orientation) * dist;
		pos.y = actor.position.y + sin(actor.orientation) * dist;
		return pos;
	}
	
	bool has_slot(int cat) {
		return is_bot(cat)
		or cat == DefenseTower
		or cat == NuclearPlant
		or cat == PowerPlant
		or cat == ResearchCenter;
	}
	
	float inverse_direction(point pos) {
		// TODO: it is possible to do it without if statement
		
		if (actor.position.y > pos.y) {
			return 270 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
		}
		
		return 90 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
	}
	
	bool is_blocked(object item) {
		return false;  // TODO
	}
	
	bool is_bot(int cat) {
		return false
		or cat == PracticeBot
		or cat == TargetBot
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber
		or cat == WheeledSniffer
		or cat == TrackedSniffer
		or cat == WingedSniffer
		or cat == LeggedSniffer
		or cat == WheeledShooter
		or cat == TrackedShooter
		or cat == WingedShooter
		or cat == LeggedShooter
		or cat == WheeledOrgaShooter
		or cat == TrackedOrgaShooter
		or cat == WingedOrgaShooter
		or cat == LeggedOrgaShooter
		or cat == Subber
		or cat == Recycler
		or cat == Shielder
		or cat == Thumper
		or cat == PhazerShooter;
	}
	
	bool is_label(int cat) {
		return false
		or cat == BlueFlag
		or cat == GreenFlag
		or cat == YellowFlag
		or cat == VioletFlag
		or cat == RedFlag
		or cat == TitaniumSpot
		or cat == UraniumSpot
		or cat == PowerSpot
		or cat == WayPoint
		or cat == Target2;
	}
	
	bool is_item(int cat) {
		return false
		or cat == TitaniumOre
		or cat == Titanium
		or cat == PowerCell;  // TODO
	}
	
	bool is_structure(int cat) {
		return false
		or cat == BotFactory
		or cat == Converter
		or cat == DefenseTower
		or cat == ResearchCenter
		or cat == PowerPlant
		or cat == PowerStation;  // TODO
	}
	
	int[] list_bots() {
		int[] bots; int i;
		
		i = 0;
		bots[i++] = WheeledGrabber;
		bots[i++] = TrackedGrabber;
		bots[i++] = WingedGrabber;
		bots[i++] = LeggedGrabber;
		bots[i++] = WheeledSniffer;
		bots[i++] = TrackedSniffer;
		bots[i++] = WingedSniffer;
		bots[i++] = LeggedSniffer;
		bots[i++] = WheeledShooter;
		bots[i++] = TrackedShooter;
		bots[i++] = WingedShooter;
		bots[i++] = LeggedShooter;
		bots[i++] = WheeledOrgaShooter;
		bots[i++] = TrackedOrgaShooter;
		bots[i++] = WingedOrgaShooter;
		bots[i++] = LeggedOrgaShooter;
		bots[i++] = Subber;
		bots[i++] = Recycler;
		bots[i++] = Shielder;
		bots[i++] = Thumper;
		bots[i++] = PhazerShooter;
		bots[i++] = PracticeBot;
		bots[i++] = TargetBot;
		
		return bots;
	}
	
	int[] list_buildable() {
		int[] structs; int i;
		
		i = 0;
		structs[i++] = BotFactory;
		structs[i++] = ResearchCenter;
		structs[i++] = RadarStation;
		structs[i++] = ExchangePost;
		structs[i++] = RepairCenter;
		structs[i++] = DefenseTower;
		structs[i++] = AutoLab;
		structs[i++] = PowerStation;
		structs[i++] = PowerPlant;
		structs[i++] = NuclearPlant;
		structs[i++] = Converter;
		structs[i++] = Derrick;
		structs[i++] = PowerCaptor;
		
		return structs;
	}
	
	int[] list_bushes() {
		int[] cats; int i;
		
		i = 0;
		cats[i++] = 70;
		cats[i++] = 71;
		cats[i++] = 72;
		cats[i++] = 73;
		cats[i++] = 74;
		
		return cats;
	}
	
	int[] list_objects_with_slot() {
		int[] cats; int i;
		
		cats = list_bots();
		i = sizeof(cats);
		cats[i++] = PowerPlant;
		cats[i++] = NuclearPlant;
		cats[i++] = ResearchCenter;
		cats[i++] = DefenseTower;
		
		return cats;
	}
	
	int[] list_recyclable() {
		int[] cats; int i;
		
		i = 0;
		cats[i++] = Wreck;
		cats[i++] = 607;
		cats[i++] = 608;
		cats[i++] = 609;
		
		return cats;
	}
	
	void log(string text) {
		file handler = new file();
		handler.open(logfile, "a");
		handler.writeln(round_digits(abstime(), 1) + " " + actor.id + " " + text);
		handler.close();
	}
	
	float normalize_angle(float angle) {
		return angle - 360 * round(angle / 360);
	}
	
	float max(float a, float b) {
		if (a > b) {
			return a;
		}
		
		return b;
	}
	
	float min(float a, float b) {
		if (a < b) {
			return a;
		}
		
		return b;
	}
	
	void orient(float direct) {
		turn(normalize_angle(direct - actor.orientation));
	}
	
	// TODO: use RadarArgs
	object radar_best_cell(int angle=0, int focus=360, int min=0, int max=1024) {
		object[] nuclear_cells; int nuclear_max_index; float nuclear_max_value;
		object[] power_cells; int power_max_index; float power_max_value;
		
		nuclear_cells = radarall(NuclearCell, angle, focus, min, max);
		nuclear_max_index = -1;
		nuclear_max_value = 0;
		
		for (int i = 0; i < sizeof(nuclear_cells); ++i) {
			if (nuclear_cells[i].energyLevel >= nuclear_max_value) {
				nuclear_max_index = i;
				nuclear_max_value = nuclear_cells[i].energyLevel;
			}
		}
		
		power_cells = radarall(PowerCell, angle, focus, min, max);
		power_max_index = -1;
		power_max_value = 0;
		
		for (int i = 0; i < sizeof(power_cells); ++i) {
			if (power_cells[i].energyLevel >= power_max_value) {
				power_max_index = i;
				power_max_value = power_cells[i].energyLevel;
			}
		}
		
		if (power_max_value >= 10 * nuclear_max_value) {
			if (power_max_value == 0) {
				return null;
			}
			
			return power_cells[power_max_index];
		}
		
		if (nuclear_max_value == 0) {
			return null;
		}
		
		return nuclear_cells[nuclear_max_index];
	}
	
	object radar_item(RadarArgs a, bool radar_ground=true, bool radar_slots=true, bool radar_load=false) {
		object[] items; object item; int[] item_cats;
		
		item_cats = a.cat;
		items = radarall(Any, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
		
		for (int i = 0; i < sizeof(items); ++i) {
			item = items[i];
			
			if (radar_ground and contains(item_cats, item.category)) {
				return item;
			}
			
			if (radar_slots and has_slot(item.category) and item.energyCell != null
			                and contains(item_cats, item.energyCell.category)) {
				return item.energyCell;
			}
			
			if (radar_load and can_load(item.category) and item.load != null
			               and contains(item_cats, item.load.category)) {
				return item.load;
			}
		}
		
		return null;
	}
	
	object radar_wait(RadarArgs a, float wait_time=nan) {
		object item;
		
		if (wait_time == nan) {
			wait_time = wait_for_cat(a.cat[0]);
		}
		
		for (;;) {
			item = radar_(a);
			
			if (item != null) {
				break;
			}
			
			if (wait_time <= 0) {
				return null;
			}
			
			wait_time -= 0.1;
			wait(0.1);
		}
		
		return item;
	}
	
	object radar_(RadarArgs a) {
		return radar(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	object[] radarall_(RadarArgs a) {
		return radarall(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	float random(float min, float max) {
		return rand() * (max - min) + min;
	}
	
	float round_cell(float value) {
		return round(value / 5 - 0.5) * 5 + 2.5;
	}
	
	float round_digits(float value, int digits) {
		int a = pow(10, digits);
		return round(value * a) / a;
	}
	
	void switch_cell() {
		grab(InFront);    drop(Behind);
		grab(EnergyCell); drop(InFront);
		grab(Behind);     drop(EnergyCell);
	}
	
	void switch_cell_quick() {
		if (actor.load != null) {
			drop();
		}
		
		grab(EnergyCell); drop(Behind);
		grab(InFront);    drop(EnergyCell);
	}
	
	void switch_for(object item) {
		assert(actor.load != null).id;
		assert(item.energyCell != null).id;
		
		turn(direction(item.position));
		drop(Behind);
		grab();
		turn(-90);
		drop();
		turn(90);
		grab(Behind);
		drop();
	}
	
	int to_int(bool flag) {
		if (flag) {
			return 1;
		}
		
		return 0;
	}
	
	int[] to_list(int cat) {
		int[] cat_list;
		
		cat_list[0] = cat;
		return cat_list;
	}
	
	point team_transform(point p) {
		if (actor.team == 2) {
			p.x *= -1;
			p.y *= -1;
			p.z = 180 + p.z;
		}
		
		return p;
	}
	
	float wait_for_cat(int cat) {
		if (cat == Titanium   ) { return 15.5; }
		if (cat == TitaniumOre) { return 10.5; }
		if (cat == PowerCell  ) { return 12.5; }
		if (cat == UraniumOre ) { return 30.5; }
		return 15.5;  // Build time
	} 
}

public class Message {
	static int max_message_capacity = 80;
	static int max_messages_count = 4;
	static string input_separator = " ";
	static string output_separator = " ";
	
	private string buffer = "";
	
	void add(string text) {
		buffer += text;
	}
	
	void show() {
		string message_buffer; int space_index;
		
		if (strlen(buffer) > max_messages_count * max_message_capacity) {
			message("Message too long " + strlen(buffer), DisplayError);
			return;
		}
		
		for (int i = max_messages_count - 1; i >= 0; --i) {
			message_buffer = "";
			
			for (int j = 0; j < 10; ++j) {
				space_index = strfind(buffer, input_separator);
				
				if (space_index == nan) {
					// last word in buffer
					message_buffer += buffer;
					buffer = "";
					break;
				}
				
				if (strlen(message_buffer) + space_index > max_message_capacity) {
					break;
				}
				
				if (strlen(message_buffer) > 0) {
					message_buffer += output_separator;
				}
				
				message_buffer += strleft(buffer, space_index);
				buffer = strright(buffer, strlen(buffer) - space_index - 1);
			}
			
			message(message_buffer);
			
			if (strlen(buffer) == 0) {
				return;
			}
		}
		
		message("Fail to split message. Too long " + strlen(buffer), DisplayError);
	}
}

public class TaskState {
	public string to_str() {
		nan * 0;  // abstract method
		return "";
	}
}

public class TaskStateProposed extends TaskState {
	public string to_str() {
		return "proposed";
	}
}

public class TaskStateInInvestigation extends TaskState {
	public string to_str() {
		return "in-investigation";
	}
}

public class TaskStateActive extends TaskState {
	public string to_str() {
		return "active";
	}
}

public class TaskStateResolved extends TaskState {
	public string to_str() {
		return "resolved";
	}
}

public class TaskStateClosed extends TaskState {
	public string to_str() {
		return "closed";
	}
}

public class TaskStateFailed extends TaskState {
	public string to_str() {
		return "failed";
	}
}

public class Goal {
	protected TaskState _state = new TaskStateProposed();
	
	public void Goal() {
		nan * 0;  // abstract class
	}
	
	public void assign(object actor) {
		nan * 0;  // abstract method
	}
	
	public void change_state(TaskState state) {
		this._state = state;
	}
	
	public bool check_prerequirements() {
		nan * 0;  // abstract method
		return false;
	}
	
	public TaskState get_state() {
		return this._state;
	}
	
	public bool equal(Goal that) {
		return this.to_str() == that.to_str();
	}
	
	public float get_resolve_time() {
		return 0;
	}
	
	public float get_close_time() {
		return this.get_resolve_time();
	}
	
	// Makes some to archieve goal
	// return: 0 if goal achieved, 1 on error
	public int make() {
		nan * 0;  // abstract method
		return 0;
	}
	
	public string to_str() {
		nan * 0;  // abstract method
		return "";
	} 
}

extern void Library_EBoost() {
	EBoost e(null);
	
	// Unit Tests
	e.assert_equal(e.normalize_angle(179), 179).id;
	e.assert_equal(e.normalize_angle(181), -179).id;
	e.assert_equal(e.normalize_angle(-179), -179).id;
	e.assert_equal(e.normalize_angle(360 * -11 + 30), 30).id;
	e.assert_equal(e.normalize_angle(360 * 4 + 30), 30).id;
	e.assert_equal(e.round_cell(-0.1), -2.5).id;
	e.assert_equal(e.round_cell(0.1), 2.5).id;
	e.assert_equal(e.round_cell(4.9), 2.5).id;
	e.assert_equal(e.round_cell(5.1), 7.5).id;
	message("Tests passed", DisplayInfo);
}
