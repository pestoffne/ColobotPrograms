public class MoveStraightFunctionVV extends FunctionVV {
	private EBoost e;
	
	public void MoveStraightFunctionVV(EBoost e) {
		this.e = e;
	}
	
	public void _() {
		e.goto_straight(new point(107, -82.5), 0);
		e.goto_straight(new point(107, -63), 0);
		e.goto_straight(new point(102, -63), 0);
		e.goto_straight(new point(102, -58), 0);
		e.goto_straight(new point(82, -58), 0);
		e.goto_straight(new point(82, -73), 0);
		e.goto_straight(new point(74.5, -73), 0);
	}
}

public class MoveSmoothFunctionVV extends FunctionVV {
	private EBoost e;
	
	public void MoveSmoothFunctionVV(EBoost e) {
		this.e = e;
	}
	
	private void turn_left_smooth() {
		motor(0.7, 1.0);
		wait(2.0);
	}
	
	private void turn_right_smooth() {
		motor(1.0, 0.7);
		wait(2.0);
	}
	
	void move_fast(float dist) {
		point start_pos;
		
		start_pos = e.actor.position;
		motor(1, 1);
		wait(dist / 5);
		message(distance2d(start_pos, e.actor.position));
	}
	
	public void _() {
		//move_fast(22.75 - 5.00);
		//turn_left_smooth();
		move_fast(5.0 * 2.5);
		turn_left_smooth();
		turn_right_smooth();
		turn_left_smooth();
		// start point (84.25, -85.5)
		/*e.goto_straight(new point(107, -85.5), 2.5);
		turn_left_smooth();
		e.goto_straight(new point(107, -63), 2.5);
		turn_left_smooth();
		e.goto_straight(new point(102, -63), 2.5);
		turn_right_smooth();
		e.goto_straight(new point(102, -58), 2.5);
		turn_left_smooth();
		e.goto_straight(new point(82, -58), 2.5);
		turn_left_smooth();
		e.goto_straight(new point(82, -73), 2.5);
		turn_right_smooth();
		e.goto_straight(new point(74.5, -73), 2.5);*/
	}
}

public class MoveNonStopFunctionVV extends FunctionVV {
	private EBoost e;
	
	public void MoveNonStopFunctionVV(EBoost e) {
		this.e = e;
	}
	
	public void fly_to(point pos) {
		float dir; PID pid;
		
		//pid = new PID(0.01, 0.0, 0.0001, 0.05);  // 20.37
		//pid = new PID(0.005, 0.0, 0.00005, 0.05);  // 20.41, 20.53
		//pid = new PID(0.005, 0.0, -0.0004, 0.05);  // 20.18, 20.19
		//pid = new PID(0.01, 0.0, -0.0001, 0.05);  // 3.0; 19.98
		//pid = new PID(0.01, 0.0, -0.0001, 0.05);  // 2.5; 19.9
		//pid = new PID(0.01, 0.0, -0.0002, 0.05);  // 2.5; 20.21
		//pid = new PID(0.01, 0.0, 0.0, 0.05);  // 2.5; 19.79, 19.63
		//pid = new PID(0.01, 0.0, 0.0, 0.05);  // 3.0; 19.4, 19.29
		//pid = new PID(0.005, 0.0, 0.0, 0.05);  // 3.0; 19.58, 19.38
		//pid = new PID(0.0075, 0.0, 0.0, 0.05);  // 3.0; 18.97
		//pid = new PID(0.01, 0, 0, 0.05); // min_x = -0.93, s = 21.63
		//pid = new PID(0.0, 0.0, 0.0001, 0.05);  // doesn't work
		//pid = new PID(0.01, 0, 0.0001, 0.05); // 1.5; 22.48
		//pid = new PID(0.007, 0, 0, 0.05); // 0.5; 19.15
		//pid = new PID(0.008, 0, 0, 0.05);  // 0.5; 20.33
		//pid = new PID(0.007, 0, 0, 0.05);  // 0.75; 19.47
		pid = new PID(0.007, 0, 0, 0.05);  // 1.0; 19.4
		
		while (distance2d(pos, e.actor.position) > 1.0) {
			//message(e.round_digits(direction(pos), 2));
			dir = pid.compute(direction(pos));
			//message(e.round_digits(direction(pos), 2) + " " + dir);
			e._motor(dir);  // 0.15
			wait(0.05);
		}
	}
	
	public void _() {
		fly_to(new point(104.5, -82.5));
		fly_to(new point(107, -80));
		
		fly_to(new point(107, -65.5));
		fly_to(new point(104.5, -63));
		fly_to(new point(102, -60.5));
		fly_to(new point(99.5, -58));
		
		fly_to(new point(84.5, -58));
		fly_to(new point(82, -60.5));
		
		fly_to(new point(82, -70.5));
		fly_to(new point(79.5, -73));
		
		fly_to(new point(74.5, -73));
	}
}

extern void object::MoveLabirint()
{
	float time;
	EBoost e(this);
	
	pendown(4, 0.1);
	//time = e.benchmark(new MoveStraightFunctionVV(e));  // 27 seconds
	//time = e.benchmark(new MoveSmoothFunctionVV_old(e));  // 22.68 seconds
	time = e.benchmark(new MoveNonStopFunctionVV(e));  // 19.15 seconds
	
	message(e.round_digits(time, 2));
	penup();
}
