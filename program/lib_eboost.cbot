public class RadarArgs {
	int[] cat;
	float angle;
	float focus;
	float min;
	float max;
	float sens;
	int filter;
	
	void RadarArgs(int[] cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		this.cat = cat;
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
	
	void RadarArgs(int cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		EBoost e(null);
		
		this.cat = e.to_list(cat);
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
}

public class EBoost {
	object actor;
	static string logfile = "common_logs.txt";
	static float pi = 3.14159265;
	
	void EBoost(object actor) {
		this.actor = actor;
		errmode(0);
	}
	
	public int aim_vertical_center(point target_position) {
		point actor_position; float ay, bx, by, actor_roll;
		
		actor_position = this.actor.position;
		actor_roll = this.actor.roll;
		
		ay = atan((target_position.z - actor_position.z - 1.5)
		    / distance2d(target_position, actor_position))
		    - this.actor.pitch;
		bx = ay * sin(actor_roll);
		by = ay * cos(actor_roll);
		return aim(by, bx);
	}
	
	public int another_team() {
		return 3 - this.actor.team;
	}

	object assert(bool value, string text="assertion error") {
		if (value) {
			return retobject(0);
		}
		
		message(text, DisplayError);
		return null;
	}
	
	object assert_equal(float a, float b) {
		return assert(a == b, "assert(" + a + " == " + b + ") failed");
	}
	
	public float benchmark(FunctionVV func) {
		float start_time;
		
		start_time = abstime();
		func._();
		return abstime() - start_time;
	}
	
	bool can_load(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber
		or cat == Subber
		or cat == Me
		or cat == AlienWasp;
	}
	
	bool can_switch_own_cell(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber;
	}
	
	public string cat_name(int cat) {
		if (cat == BotFactory) { return "BotFactory"; }
		if (cat == Converter) { return "Converter"; }
		if (cat == Derrick) { return "Derrick"; }
		if (cat == DefenseTower) { return "DefenseTower"; }
		if (cat == PowerPlant) { return "PowerPlant"; }
		if (cat == PowerStation) { return "PowerStation"; }
		if (cat == ResearchCenter) { return "ResearchCenter"; }
		if (cat == WheeledGrabber) { return "WheeledGrabber"; }
		if (cat == WingedGrabber) { return "WingedGrabber"; }
		if (cat == WingedShooter) { return "WingedShooter"; }
		if (cat == Shielder) { return "Shielder"; }
		// TODO: add other
		return "" + cat;
	}
	
	float _get_energy_level(object item) {
		if (item.category == PowerCell) {
			return item.energyLevel;
		}
		
		if (item.category == NuclearCell) {
			return item.energyLevel * 10;
		}
		
		assert(false, "_get_energy_level of non cell").id;
		return 0;  // never executes
	}
	
	int check_energy(float need_energy=0.33) {
		// Charge methods priorities
		// 1) Goto PowerStation [only PowerCell]
		// 2) Goto switch cell  [only Grabbers]
		// 3) Goto PowerCaptor  [only PowerCell]
		// 4) Ask for help
		object item;
		
		if (actor.energyCell == null
		            or actor.energyCell.category != PowerCell
		           and actor.energyCell.category != NuclearCell) {
			return 1;
		}
		
		if (_get_energy_level(actor.energyCell) >= need_energy) {
			return 0;  // Energy level is already ok
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station() == 0) {
				return 0;
			}
		}
		
		if (can_switch_own_cell(actor.category)) {
			if (go_switch_cell() == 0) {
				return 0;
			}
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station(PowerCaptor, 180.0) == 0) {
				return 0;
			}
		}
		
		return 1;
	}
	
	void check_energy_loop(float need_energy=0.33) {
		bool first;
		
		first = true;
		
		for (;;) {
			if (check_energy(need_energy) == 0) {
				return;
			}
			
			if (first) {
				message("I need help with charge", DisplayWarning);
			}
			
			wait(1);
			first = false;
		}
	}
	
	int check_shield(float need_shield=0.5) {
		object item;
		
		if (actor.shieldLevel >= need_shield) {
			return 0;
		}
		
		return go_repair();
	}
	
	bool contains(int[] list, int value) {
		for (int i = 0; i < sizeof(list); ++i) {
			if (list[i] == value) {
				return true;
			}
		}
		
		return false;
	}
	
	void dock_to_ship() {
		point ship_pos; point[] slots; point slot; int i;
		
		ship_pos = radar(SpaceShip).position;
		
		// create list of slots. better to do it staticaly
		i = 0;
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 4.0, 150);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 4.0,  30);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 4.0,  90);
		
		for (i = 0; i < sizeof(slots); ++i) {
			slot = slots[i];
			
			if (search(Any, slot, 0, 1.3) == null) {
				goto_p(slot, 2);
				move(0.5);
				
				if (drop() == 0) {
					break;
				}
			}
		}
	}
	
	bool _helix_helper(point pos) {
		object item;
		
		item = search(Any, pos, 0, 1.7);
		
		if (item != null and not is_label(item.category)) {
			return false;
		}
		
		for (int i = 0; i < 4; ++i) {
			if (goto_p(pos) == 0 and drop() == 0) {
				return true;
			}
			
			pos.z += 90;
		}
		
		return false;
	}
	
	public int drop_to_converter() {
		// TODO: check Converter is near, check load is TitaniumOre
		return this.drop_to_ground();
	}
	
	public int drop_to_energy_cell(int slot_cat) {
		int item_cat, energy_level; object actor_load, slot;
		
		actor_load = this.actor.load;
		
		if (actor_load == null) {
			return 1;
		}
		
		item_cat = actor_load.category;
		energy_level = actor_load.energyLevel;
		
		// TODO: check slot before drop
		
		if (drop() != 0) {
			return 1;
		}
		
		slot = radar(slot_cat, 0, 30, 0, 10, FilterFriendly);
		
		if (slot == null or slot.energyCell == null or this.actor.load != null) {
			return 1;
		}
		
		return 0;
	}
	
	int drop_to_ground() {
		int cat, energy_level; point pos; object item;
		
		if (actor.load == null) {
			return 1;
		}
		
		cat = actor.load.category;
		energy_level = actor.load.energyLevel;
		
		if (drop() != 0) {
			return 1;
		}
		
		pos.x = actor.position.x + 1.5 * cos(actor.orientation);
		pos.y = actor.position.y + 1.5 * sin(actor.orientation);
		
		item = search(cat, pos);
		
		if (item == null or distance2d(pos, item.position) > 0.25 or item.energyLevel != energy_level) {
			return 1;
		}
		
		return 0;
	}
	
	void drop_to_helix(point p) {
		int s;
		
		s = 2;
		p.z = 270;  // angle
		
		for (int l = 1; l <= 7; ++l) {
			for (int i = 0; i < l; ++i) {
				if (_helix_helper(p)) {
					return;
				}
				
				p.x += s;
			}
			
			s *= -1;
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
			
			for (int i = 0; i < l; ++i) {
				if (_helix_helper(p)) {
					return;
				}
				
				p.y += s;
			}
			
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
		}
	}
	
	public int factory_bot(int bot_cat, string program) {
		object item; float wait_time;
		
		item = radar_wait(new RadarArgs(BotFactory, 0, 360, 0, 1024, 1, FilterFriendly | FilterNeutral));
		
		if (item == null) {
			this.log("warning factory_bot BotFactory not found");
			return 1;
		}
		
		this.goto_pp(item.position, this.normalize_angle(180 + item.orientation), 5.5);
		move(3.0);
		this.drop_to_ground();
		turn(180);
		move(3.0);
		
		wait_time = 60;  // max research time
		
		//while (item.factory(bot_cat, program) != 0) {  // for v0.1
		while (factory(bot_cat, program, item) != 0) {  // for v0.2
			wait(0.1);
			wait_time -= 0.1;
			
			if (wait_time <= 0) {
				this.log("warning factory_bot can not factory, timeout expired");
				return 1;
			}
		}
		
		return 0;
	}
	
	public int fill_bot(int bot_cat) {
		object item;
		
		// TODO: assume there is one BotFactory
		item = this.radar_wait(new RadarArgs(BotFactory, 0, 360, 0, 1024, 1, FilterFriendly | FilterNeutral));
		
		if (item == null) {
			return 1;
		}
		
		this.goto_pp(item.position, this.normalize_angle(180 + item.orientation), 5.5);
		item = this.radar_wait(new RadarArgs(bot_cat, 0, 30, 0, 20));
		
		if (item == null) {
			this.log("warning fill_q failed to find Bot, timeout expired");
			return 1;
		}
		
		goto(item.position);
		
		if (this.drop_to_energy_cell(bot_cat) != 0) {
			this.log("warning fill_q failed to insert PowerCell");
			return 1;
		}
		
		move(-1.5);
		return 0;
	}
	
	point fire_position(object item) {
		point pos;
		
		pos = item.position;
		
		if (item.category == PowerStation or item.category == Converter) {
			pos.x -= cos(item.orientation) * 2.5;
			pos.y -= sin(item.orientation) * 2.5;
		}
		
		return pos;
	}
	
	/*private*/ void _jet_to(float target_z) {
		jet(this.min_max(0.1 * (target_z - this.actor.position.z), -0.5, 0.5));
	}
	
	/*private*/ void _motor(float dir) {
		float x;
		dir = this.min_max(dir, -1.0, 1.0);
		x = 1 - 2 * abs(dir);
		
		if (dir > 0) {
			motor(x, 1);
		} else {
			motor(1, x);
		}
	}
	
	public void fly_to(point pos) {
		float dir; PID pid;
		
		pid = new PID(0.02, 0.0, 0.0002, 0.05);
		
		while (distance(pos, this.actor.position) > 5.0) {
			dir = pid.compute(direction(pos));
			this._motor(dir);
			this._jet_to(pos.z - 0.75);
			wait(0.05);
		}
	}
	
	public void fly_to(point pos, float angle) {
		float dir, dist; PID pid; point qos;
		
		pid = new PID(0.02, 0.0, 0.0002, 0.05);
		
		for (;;) {
			dist = distance(pos, this.actor.position);
			
			if (dist <= 3.0) { // TODO: check angle
				break;
			}
			
			qos.x = pos.x - cos(angle) * dist * 0.25;
			qos.y = pos.y - sin(angle) * dist * 0.25;
			dir = pid.compute(direction(qos));
			this._motor(dir);
			this._jet_to(pos.z - 0.75);
			wait(0.05);
		}
	}
	
	public void fly_to(object item) {
		float item_orientation, dir_qos, dir_pid, dist_to_item, koef; PID pid; point item_position, qos;
		
		pid = new PID(0.02, 0.0, 0.0002, 0.05);
		// TODO: check unit is alive
		
		for (;;) {
			item_position = item.position;
			item_orientation = item.orientation;
			dist_to_item = distance(item_position, this.actor.position);
			koef = max(-5, 5 - dist_to_item * 0.25);
			qos.x = item_position.x + cos(item_orientation) * koef;
			qos.y = item_position.y + sin(item_orientation) * koef;
			dir_qos = this.normalize_angle(direction(qos));
			dir_pid = pid.compute(dir_qos);
			this._motor(dir_pid);
			this._jet_to(item_position.z);
			
			if (abs(dir_qos) < 5.0 and dist_to_item < 20.0) {
				fire(0.1);
				break;
			}
			
			wait(0.05);
		}
	}
	
	public int fly_ground(float jet_value=-1) {
		float ground_z; int retries;
		
		for (retries = 100; retries >= 0; --retries) {
			ground_z = topo(actor.position);
			
			if (ground_z == actor.position.z) {
				return 0;
			}
			
			jet(jet_value);
			wait(0.1);
		}
		
		return 1;
	}
	
	float get_height(int cat) {
		float h;
		
		if (cat == Derrick) { h = 35;
		} else if (cat == BotFactory) { h = 28;
		} else if (cat == RepairCenter) { h = 30;
		} else if (cat == PowerStation) { h = 13;
		} else if (cat == Converter) { h = 20;
		} else if (cat == DefenseTower) { h = 30;
		} else if (cat == ResearchCenter) { h = 22;
		} else if (cat == RadarStation) { h = 19;
		} else if (cat == PowerPlant) { h = 20;
		} else if (cat == AutoLab) { h = 16;
		} else if (cat == NuclearPlant) { h = 40;
		} else if (cat == ExchangePost) { h = 19;
		} else {
			return 1.5;  // Assume it is Bot
		}
		
		return h * 0.25;
	}
	
	public point get_next_position_line(object item, float dt) {
		int item_category; point item_position, item_velocity, next_position;
		
		item_category = item.category;
		item_position = item.position;
		item_velocity = this.get_velocity(item);
		
		// ignore items that could stop item
		next_position.x = item_position.x + dt * item_velocity.x;
		next_position.y = item_position.y + dt * item_velocity.y;
		
		if (item_category == AlienWasp) {
			next_position.z = this.max(8.5, 8.5 + topo(next_position));
		} else if (this.is_winged_bot(item_category)) {
			// there is maximum z for bots, we ignore it here
			next_position.z = this.max(item_position.z + dt * item_velocity.z, topo(next_position));
		} else {
			// assume item is ground unit
			next_position.z = topo(next_position) + (item_position.z - topo(item_position));
		}
		
		return next_position;
	}
	
	//              | 7 8 9 |            | -1 0 1 |            |  1  1  1 |
	// slot_index = | 4 5 6 | , sign_x = | -1 0 1 | , sign_y = |  0  0  0 |
	//              | 1 2 3 |            | -1 0 1 |            | -1 -1 -1 |
	public point get_ship_slot_position(int slot_index) {
		int slot_index_p_2, sign_x, sign_y;
		
		slot_index_p_2 = slot_index + 2;
		sign_x = slot_index_p_2 % 3 - 1;
		sign_y = slot_index_p_2 / 3 - 2;
		
		return get_ship_slot_position(sign_x, sign_y);
	}
	
	public point get_ship_slot_position(int sign_x, int sign_y) {
		point ship_pos;
		
		ship_pos = radar(SpaceShip).position;
		
		return new point(
		ship_pos.x + sign_x * 3.25,
		ship_pos.y + sign_y * 3.25,
		ship_pos.z + 7.5
		);
	}
	
	public point get_velocity(object item) {
		point item_velocity;
		
		item_velocity = item.velocity;
		
		if (item_velocity.x == nan) {
			item_velocity.x = 0.0;
		}
		
		if (item_velocity.y == nan) {
			item_velocity.y = 0.0;
		}
		
		if (item_velocity.z == nan) {
			item_velocity.z = 0.0;
		}
		
		return item_velocity;
	}
	
	// return 0 -- PowerCell was recharged
	//        1 -- failed to recharge on PowerStation
	int go_power_station(int cat=PowerStation, float wait_time=15.5) {
		object item;
		
		for (;;) {
			item = radar(cat);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				} else {
					motor(0, 0);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(cat, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.energyCell == null or actor.energyCell.category != PowerCell) {
					return 1;
				}
				
				if (actor.energyCell.energyLevel > 0.95) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_repair() {
		object item; float wait_time;
		
		for (;;) {
			item = radar(RepairCenter);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			wait_time = 15.5;
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(RepairCenter, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.shieldLevel >= 1) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_switch_cell() {
		object item;
		
		if (not can_switch_own_cell(actor.category)) {
			return 1;
		}
		
		item = radar_best_cell(0, 360, 0, 50);
		
		if (item == null) {
			return 1;
		}
		
		goto(item.position);
		switch_cell();
		return 0;
	}
	
	int goto_grab(int cat) {  // TODO: grab from slots
		object item;
		
		item = radar(cat);
		
		if (item == null) {
			return 1;
		}
		
		goto(item.position);
		grab();
		return 0;
		
		/* code above does not work
		if (goto_radar_position(new RadarArgs(cat)) != 0) {
			log("warning goto_grab (cat = " + cat + ") failed on step 1 -- goto_radar_position");
			return 1;
		}
		
		if (grab_from_ground(cat) != 0) {
			log("warning goto_grab (cat = " + cat + ") failed on step 2 -- grab_from_ground");
			return 1;
		}
		
		log("info goto_grab ok");
		*/
		return 0;
	}
	
	int goto_o(point pos, float dist=1.5) {
		return goto_pp(pos, inverse_direction(pos), dist);
	}
	
	int goto_o_behind(point pos, float dist=1.5) {
		// TODO: failsafe
		turn(normalize_angle(direction(pos) + 180));
		move(dist - distance2d(actor.position, pos));
		return 0;
	}
	
	int goto_p(point pos, float dist=1.5) {
		return goto_pp(pos, pos.z, dist);
	}
	
	int goto_pp(point pos, float direct, float dist=1.5) {
		float dist_to_pos;
		
		pos.x -= cos(direct) * dist;
		pos.y -= sin(direct) * dist;
		log("info goto_pp (pos = " + pos.x + ";" + pos.y + ")");
		
		if (distance2d(actor.position, pos) >= 8.0) {
			goto(pos);
		}
		
		dist_to_pos = distance2d(actor.position, pos);
		
		if (dist_to_pos > 0.1 and dist_to_pos < 10.0) {
			goto_straight(pos, 0);  // to more precise position
		}
		
		if (distance2d(actor.position, pos) >= 0.5) {
			log("warning goto_pp failed (distance = " + dist_to_pos + ")");
			return 1;
		}
		
		orient(direct);
		log("info goto_pp ok");
		return 0;
	}
	
	int goto_8(point pos) {
		/*float angle;
		
		angle = inverse_direction(pos);
		
		for (int i = 0; i < 7; ++i) {
			if (goto_pp(pos, normalize_angle(angle + 45 * i), 2) == 0)  {
				move(0.5);
				log("info goto_8 (pos = " + pos.x + ";" + pos.y + ") ok");
				return 0;
			}
		}
		
		log("info goto_8 (pos = " + pos.x + ";" + pos.y + ") ok");
		return 1;*/
		return goto_o(pos);
	}
	
	int goto_radar_item_position(RadarArgs a, bool grab_ground=true, bool grab_slots=true, bool grab_load=false) {
		object item; float angle;
		
		item = radar_item(a, grab_ground, grab_slots, grab_load);
		
		if (item == null) {
			log("warning goto_radar_item_position item does not found");
			return 1;
		}
		
		// TODO: use correct orientation to grab from slot
		return goto_8(item.position);
	}
	
	int goto_radar_position(RadarArgs a) {
		object item;
		
		log("info goto_radar_position run");
		item = radar_(a);
		
		if (item == null) {
			log("warning goto_radar_position item does not found");
			return 1;
		}
		
		if (goto_8(item.position) != 0) {
			log("warning goto_radar_position failed on goto_8");
			return 1;
		}
		
		log("info goto_radar_position ok");
		return 0;
	}
	
	public int goto_retries(point pos, int retries=5) {
		for (;retries > 0; --retries) {
			if (goto(pos) == 0) {
				return 0;
			}
			
			wait(1);
		}
		
		return 1;
	}
	
	void goto_straight(point pos, float dist=1.5) {
		turn(direction(pos));
		move(distance2d(pos, actor.position) - dist);
	}
	
	void _drop_out() {
		point pos;
		
		pos = actor.position;
		pos.z = actor.orientation;
		goto(space(actor.position, 3));
		drop();
		goto_p(pos);
	}
	
	public int grab_from_energy_cell(int item_cat, int container_cat, float min_energy=0, float max_energy=1) {
		object container, actor_load; float wait_time;
		
		if (this.actor.load != null) {
			if (this.actor.load.category == item_cat) {
				log("warning grab_from_energy_cell needed item is already loaded before grab");
				return 0;
			} else {
				log("warning grab_from_energy_cell another item is already loaded before grab");
				return 1;
			}
		}
		
		if (container_cat == PowerPlant) {
			wait_time = 12.5;
		} else {
			wait_time = 0.5;
		}
		
		for (;;) {
			container = radar(container_cat, 0, 30, 0, 10);
			
			if (container == null) {
				log("warning grab_from_energy_cell can not find container grab from");
				return 1;
			}
			
			if (container.energyCell != null and container.energyCell.category == item_cat) {
				break;
			}
			
			if (wait_time <= 0) {
				log("warning grab_from_energy_cell can not find item to grab, timeout expired");
				return 1;
			}
			
			wait(0.1);
			wait_time -= 0.1;
		}
		
		grab();
		actor_load = this.actor.load;
		
		if (actor_load == null) {
			log("warning grab_from_energy_cell load is null after grab");
			return 1;
		}
		
		if (actor_load.category != item_cat) {
			log("warning grab_from_energy_cell load.category has unexpected value");
			return 1;
		}
		
		if (actor_load.energyLevel < min_energy or actor_load.energyLevel > max_energy) {
			log("warning grab_from_energy_cell expect load.energyLevel in [" + min_energy + ";" + max_energy + "], but actual value is " + actor_load.energyLevel);
			return 1;
		}
		
		return 0;
	}
	
	int grab_from_ground(int cat, int oper=InFront, float min_energy=-1, float max_energy=1) {
		float max_wait; RadarArgs radar_args;
		
		log("info grab_from_ground (cat = " + cat + ") run");
		
		for (int retries = 3; retries >= 0; --retries) {
			if (actor.load == null) {
				break;
			}
			
			if (actor.load.category == cat and actor.load.energyLevel >= min_energy
			                               and actor.load.energyLevel <= max_energy) {
				log("warning grab_from_ground needed item is already loaded before grab");
				return 0;
			}
			
			log("warning grab_from_ground another item is already loaded before grab");
			_drop_out();
		}
		
		radar_args = new RadarArgs(cat, 0, 30, 0, 6);
		
		if (oper == Behind) {
			radar_args.angle = 180;
		}
		
		for (int retries = 3; retries >= 0; --retries) {
			if (radar_wait(radar_args) == null) {
				break;
			}
			
			grab(oper);
			
			if (actor.load == null) {
				wait(0.5);
				continue;
			} else {
				if (actor.load.category == cat and actor.load.energyLevel >= min_energy and actor.load.energyLevel <= max_energy) {
					log("info grab_from_ground (cat = " + cat + ") ok");
					return 0;
				}
			}
			
			log("warning grab_from_ground another item is loaded after grab");
			_drop_out();
		}
		
		log("warning grab_from_ground can not find expected object in front -- timeout expired");
		return 1;
	}
	
	public point grab_position(float dist=1.5) {
		point ret_pos, actor_position; float actor_orientation;
		
		actor_position = this.actor.position;
		actor_orientation = this.actor.orientation;
		
		ret_pos.x = actor_position.x + cos(actor_orientation) * dist;
		ret_pos.y = actor_position.y + sin(actor_orientation) * dist;
		return ret_pos;
	}
	
	bool has_slot(int cat) {
		return is_bot(cat)
		or cat == AutoLab
		or cat == DefenseTower
		or cat == NuclearPlant
		or cat == PowerPlant
		or cat == ResearchCenter;
	}
	
	float inverse_direction(point pos) {
		// TODO: it is possible to do it without if statement
		
		if (actor.position.y > pos.y) {
			return 270 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
		}
		
		return 90 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
	}
	
	bool is_blocked(object item) {
		return false;  // TODO
	}
	
	bool is_bot(int cat) {
		return false
		or cat == PracticeBot
		or cat == TargetBot
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber
		or cat == WheeledSniffer
		or cat == TrackedSniffer
		or cat == WingedSniffer
		or cat == LeggedSniffer
		//* for v0.2
		or cat == WheeledBuilder
		or cat == TrackedBuilder
		or cat == WingedBuilder
		or cat == LeggedBuilder
		//*/
		or cat == WheeledShooter
		or cat == TrackedShooter
		or cat == WingedShooter
		or cat == LeggedShooter
		or cat == WheeledOrgaShooter
		or cat == TrackedOrgaShooter
		or cat == WingedOrgaShooter
		or cat == LeggedOrgaShooter
		or cat == Subber
		or cat == Recycler
		or cat == Shielder
		or cat == Thumper
		or cat == PhazerShooter;
	}
	
	bool is_label(int cat) {
		return false
		or cat == BlueFlag
		or cat == GreenFlag
		or cat == YellowFlag
		or cat == VioletFlag
		or cat == RedFlag
		or cat == TitaniumSpot
		or cat == UraniumSpot
		or cat == PowerSpot
		or cat == WayPoint
		or cat == Target2;
	}
	
	// items, which can be grabbed
	bool is_item(int cat) {
		return false
		or cat == TitaniumOre
		or cat == Titanium
		or cat == PowerCell
		or cat == UraniumOre
		or cat == NuclearCell
		or cat == OrgaMatter
		or cat == TNT
		or cat == KeyA
		or cat == KeyB
		or cat == KeyC
		or cat == KeyD;
	}
	
	// destroyable structures, which can be build
	bool is_structure(int cat) {
		return false
		or cat == AutoLab
		or cat == BotFactory
		or cat == Converter
		or cat == DefenseTower
		or cat == Derrick
		or cat == ExchangePost
		or cat == NuclearPlant
		or cat == RadarStation
		or cat == RepairCenter
		or cat == ResearchCenter
		or cat == PowerCaptor
		or cat == PowerPlant
		or cat == PowerStation;
	}
	
	bool is_winged_bot(int cat) {
		return false
		or cat == WingedGrabber
		or cat == WingedSniffer
		//* for v0.2
		or cat == WingedBuilder
		//*/
		or cat == WingedShooter
		or cat == WingedOrgaShooter;
	}
	
	int[] list_aliens() {
		int[] a; int i;
		
		i = 0;
		a[i++] = AlienAnt;
		a[i++] = AlienSpider;
		a[i++] = AlienWasp;
		a[i++] = AlienWorm;
		
		return a;
	}
	
	int[] list_bots() {
		int[] a; int i;
		
		i = 0;
		a[i++] = WheeledGrabber;
		a[i++] = TrackedGrabber;
		a[i++] = WingedGrabber;
		a[i++] = LeggedGrabber;
		a[i++] = WheeledSniffer;
		a[i++] = TrackedSniffer;
		a[i++] = WingedSniffer;
		a[i++] = LeggedSniffer;
		//* for v0.2
		a[i++] = WheeledBuilder;
		a[i++] = TrackedBuilder;
		a[i++] = WingedBuilder;
		a[i++] = LeggedBuilder;
		//*/
		a[i++] = WheeledShooter;
		a[i++] = TrackedShooter;
		a[i++] = WingedShooter;
		a[i++] = LeggedShooter;
		a[i++] = WheeledOrgaShooter;
		a[i++] = TrackedOrgaShooter;
		a[i++] = WingedOrgaShooter;
		a[i++] = LeggedOrgaShooter;
		a[i++] = Subber;
		a[i++] = Recycler;
		a[i++] = Shielder;
		a[i++] = Thumper;
		a[i++] = PhazerShooter;
		a[i++] = PracticeBot;
		a[i++] = TargetBot;
		
		return a;
	}
	
	int[] list_buildable() {
		int[] a; int i;
		
		i = 0;
		a[i++] = AutoLab;
		a[i++] = BotFactory;
		a[i++] = Converter;
		a[i++] = DefenseTower;
		a[i++] = Derrick;
		a[i++] = ExchangePost;
		a[i++] = NuclearPlant;
		a[i++] = PowerStation;
		a[i++] = PowerPlant;
		a[i++] = PowerCaptor;
		a[i++] = RadarStation;
		a[i++] = RepairCenter;
		a[i++] = ResearchCenter;
		
		return a;
	}
	
	int[] list_bushes() {
		int[] a; int i;
		
		i = 0;
		a[i++] = 70;
		a[i++] = 71;
		a[i++] = 72;
		a[i++] = 73;
		a[i++] = 74;
		
		return a;
	}
	
	int[] list_healable() {
		int[] a; int i;
		
		a = this.list_bots();
		i = sizeof(a);
		a[i++] = AutoLab;
		a[i++] = BotFactory;
		a[i++] = Converter;
		a[i++] = DefenseTower;
		a[i++] = Derrick;
		a[i++] = ExchangePost;
		a[i++] = NuclearPlant;
		a[i++] = PowerStation;
		a[i++] = PowerPlant;
		a[i++] = PowerCaptor;
		a[i++] = RadarStation;
		a[i++] = RepairCenter;
		a[i++] = ResearchCenter;
		
		return a;
	}
	
	int[] list_objects_with_slot() {
		int[] a; int i;
		
		a = list_bots();
		i = sizeof(a);
		a[i++] = AutoLab;
		a[i++] = DefenseTower;
		a[i++] = NuclearPlant;
		a[i++] = PowerPlant;
		a[i++] = ResearchCenter;
		
		return a;
	}
	
	int[] list_recyclable() {
		int[] cats; int i;
		
		i = 0;
		cats[i++] = Wreck;
		cats[i++] = 607;
		cats[i++] = 608;
		cats[i++] = 609;
		
		return cats;
	}
	
	void log(string text) {
		file handler = new file();
		handler.open(logfile, "a");
		handler.writeln(round_digits(abstime(), 1) + " " + actor.id + " " + text);
		handler.close();
	}
	
	float normalize_angle(float angle) {
		return angle - 360 * round(angle / 360);
	}
	
	float max(float a, float b) {
		if (a > b) {
			return a;
		}
		
		return b;
	}
	
	float min(float a, float b) {
		if (a < b) {
			return a;
		}
		
		return b;
	}
	
	public float min_max(float value, float min_value, float max_value) {
		if (value <= min_value) {
			return min_value;
		}
		
		if (value >= max_value) {
			return max_value;
		}
		
		return value;
	}
	
	// like move, but doesn't stop in the end
	public void move_fast(float dist) {
		motor(1, 1);
		wait(dist / 5);
	}
	
	void orient(float direct) {
		turn(normalize_angle(direct - actor.orientation));
	}
	
	public string point_2d_to_str(point p, int digits=1) {
		return "("
		+ this.round_digits(p.x, digits) + ", "
		+ this.round_digits(p.y, digits) + ")";
	}
	
	public string point_3d_to_str(point p, int digits=1) {
		return "("
		+ this.round_digits(p.x, digits) + ", "
		+ this.round_digits(p.y, digits) + ", "
		+ this.round_digits(p.z, digits) + ")";
	}
	
	// TODO: use RadarArgs
	object radar_best_cell(int angle=0, int focus=360, int min=0, int max=1024) {
		object[] nuclear_cells; int nuclear_max_index; float nuclear_max_value;
		object[] power_cells; int power_max_index; float power_max_value;
		
		nuclear_cells = radarall(NuclearCell, angle, focus, min, max);
		nuclear_max_index = -1;
		nuclear_max_value = 0;
		
		for (int i = 0; i < sizeof(nuclear_cells); ++i) {
			if (nuclear_cells[i].energyLevel >= nuclear_max_value) {
				nuclear_max_index = i;
				nuclear_max_value = nuclear_cells[i].energyLevel;
			}
		}
		
		power_cells = radarall(PowerCell, angle, focus, min, max);
		power_max_index = -1;
		power_max_value = 0;
		
		for (int i = 0; i < sizeof(power_cells); ++i) {
			if (power_cells[i].energyLevel >= power_max_value) {
				power_max_index = i;
				power_max_value = power_cells[i].energyLevel;
			}
		}
		
		if (power_max_value >= 10 * nuclear_max_value) {
			if (power_max_value == 0) {
				return null;
			}
			
			return power_cells[power_max_index];
		}
		
		if (nuclear_max_value == 0) {
			return null;
		}
		
		return nuclear_cells[nuclear_max_index];
	}
	
	object radar_item(RadarArgs a, bool radar_ground=true, bool radar_slots=true, bool radar_load=false) {
		object[] items; object item; int[] item_cats;
		
		item_cats = a.cat;
		items = radarall(Any, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
		
		for (int i = 0; i < sizeof(items); ++i) {
			item = items[i];
			
			if (radar_ground and contains(item_cats, item.category)) {
				return item;
			}
			
			if (radar_slots and has_slot(item.category) and item.energyCell != null
			                and contains(item_cats, item.energyCell.category)) {
				return item.energyCell;
			}
			
			if (radar_load and can_load(item.category) and item.load != null
			               and contains(item_cats, item.load.category)) {
				return item.load;
			}
		}
		
		return null;
	}
	
	object radar_wait(RadarArgs a, float wait_time=nan) {
		object item;
		
		if (wait_time == nan) {
			wait_time = wait_for_cat(a.cat[0]);
		}
		
		for (;;) {
			item = radar_(a);
			
			if (item != null) {
				break;
			}
			
			if (wait_time <= 0) {
				return null;
			}
			
			wait_time -= 0.1;
			wait(0.1);
		}
		
		return item;
	}
	
	object radar_(RadarArgs a) {
		return radar(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	object[] radarall_(RadarArgs a) {
		return radarall(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	float random(float min, float max) {
		return rand() * (max - min) + min;
	}
	
	float round_cell(float value) {
		return round(value / 5 - 0.5) * 5 + 2.5;
	}
	
	float round_digits(float value, int digits) {
		int a = pow(10, digits);
		return round(value * a) / a;
	}
	
	void switch_cell() {
		grab(InFront);    drop(Behind);
		grab(EnergyCell); drop(InFront);
		grab(Behind);     drop(EnergyCell);
	}
	
	void switch_cell_quick() {
		if (actor.load != null) {
			drop();
		}
		
		grab(EnergyCell); drop(Behind);
		grab(InFront);    drop(EnergyCell);
	}
	
	void switch_for(object item) {
		assert(actor.load != null).id;
		assert(item.energyCell != null).id;
		
		turn(direction(item.position));
		drop(Behind);
		grab();
		turn(-90);
		drop();
		turn(90);
		grab(Behind);
		drop();
	}

	point team_transform(point p) {
		if (actor.team == 2) {
			p.x *= -1;
			p.y *= -1;
			p.z = 180 + p.z;
		}
		
		return p;
	}
		
	int to_int(bool flag) {
		if (flag) {
			return 1;
		}
		
		return 0;
	}
	
	int[] to_list(int cat) {
		int[] cat_list;
		
		cat_list[0] = cat;
		return cat_list;
	}
	
	public string to_str(point p) {
		return this.point_3d_to_str(p);
	}

	/*private*/ float _radius_to_motor_value(float radius) {
		return 1 - 2 / (radius + 1);
	}
	
	/*private*/ float _predict_velocity(float motor_left, float motor_right) {
		return (motor_left + motor_right) * 2.5;
	}

	/*private*/ float _arc_length(float angle, float radius) {
		return this.pi * angle * radius / 180;
	}
	
	public void turn_arc(float angle, float radius) {
		float motor_value, motor_time, arc_length, predict_velocity;
		
		motor_value = this._radius_to_motor_value(radius);
		motor_time = this._arc_length(angle, radius)
		/ this._predict_velocity(motor_value, 1);
		
		if (angle > 0) {
			motor(motor_value, 1);  // turn left
		} else {
			motor(1, motor_value);  // turn right
		}
		
		wait(motor_time);
	}
	
	float wait_for_cat(int cat) {
		if (cat == Titanium   ) { return 15.5; }
		if (cat == TitaniumOre) { return 10.5; }
		if (cat == PowerCell  ) { return 12.5; }
		if (cat == UraniumOre ) { return 30.5; }
		return 15.5;  // Build time
	} 
}

public class PID {
	private float _kp;
	private float _ki;
	private float _kd;
	private float _dt;
	private float _integral = 0;
	private float _prev_error = nan;
	
	public void PID(float kp, float ki, float kd, float dt) {
		this._kp = kp;
		this._ki = ki;
		this._kd = kd;
		this._dt = dt;
	}
	
	public float compute(float error) {
		float p_out, i_out, d_out;
		
		p_out = this._kp * error;
		
		this._integral += error * this._dt;
		i_out = this._ki * this._integral;
		
		if (this._prev_error == nan) {
			this._prev_error = error;
		}
		
		d_out = this._kd * (error - this._prev_error) / this._dt;
		
		this._prev_error = error;
		return p_out + i_out + d_out;
	}
}

public class CoordinateSystem {
	private float _x0;
	private float _y0;
	private float _z0;
	
	public void CoordinateSystem(point p0) {
		this._x0 = p0.x;
		this._y0 = p0.y;
		this._z0 = p0.z;
	}
	
	public point _(point p) {
		p.x += _x0;
		p.y += _y0;
		p.z += _z0;
		return p;
	}	
}

// Pointer to function which returns void and get 0 arguments
public class FunctionVV {
	// Mathod "_" should be overriden is subclass
	public void _() {
		nan * 0;  // abstract method
	}
}

public class Message {
	static int max_message_capacity = 80;
	static int max_messages_count = 4;
	static string input_separator = " ";
	static string output_separator = " ";
	
	private string buffer = "";
	
	void add(string text) {
		buffer += text;
	}
	
	void show() {
		string message_buffer; int space_index;
		
		if (strlen(buffer) > max_messages_count * max_message_capacity) {
			message("Message too long " + strlen(buffer), DisplayError);
			return;
		}
		
		for (int i = max_messages_count - 1; i >= 0; --i) {
			message_buffer = "";
			
			for (int j = 0; j < 10; ++j) {
				space_index = strfind(buffer, input_separator);
				
				if (space_index == nan) {
					// last word in buffer
					message_buffer += buffer;
					buffer = "";
					break;
				}
				
				if (strlen(message_buffer) + space_index > max_message_capacity) {
					break;
				}
				
				if (strlen(message_buffer) > 0) {
					message_buffer += output_separator;
				}
				
				message_buffer += strleft(buffer, space_index);
				buffer = strright(buffer, strlen(buffer) - space_index - 1);
			}
			
			message(message_buffer);
			
			if (strlen(buffer) == 0) {
				return;
			}
		}
		
		message("Fail to split message. Too long " + strlen(buffer), DisplayError);
	}
}

public class TaskState {
	public string to_str() {
		nan * 0;  // abstract method
		return "";
	}
}

public class TaskStateProposed extends TaskState {
	public string to_str() {
		return "proposed";
	}
}

public class TaskStateInInvestigation extends TaskState {
	public string to_str() {
		return "in-investigation";
	}
}

public class TaskStateActive extends TaskState {
	public string to_str() {
		return "active";
	}
}

public class TaskStateResolved extends TaskState {
	public string to_str() {
		return "resolved";
	}
}

public class TaskStateClosed extends TaskState {
	public string to_str() {
		return "closed";
	}
}

public class TaskStateFailed extends TaskState {
	public string to_str() {
		return "failed";
	}
}

public class Goal {
	protected TaskState _state = new TaskStateProposed();
	
	public void Goal() {
		nan * 0;  // abstract class
	}
	
	public void assign(object actor) {
		nan * 0;  // abstract method
	}
	
	public void change_state(TaskState state) {
		this._state = state;
	}
	
	public bool check_prerequirements() {
		nan * 0;  // abstract method
		return false;
	}
	
	public TaskState get_state() {
		return this._state;
	}
	
	public bool equal(Goal that) {
		return this.to_str() == that.to_str();
	}
	
	public float get_resolve_time() {
		return 0;
	}
	
	public float get_close_time() {
		return this.get_resolve_time();
	}
	
	// Makes some to archieve goal
	// return: 0 if goal achieved, 1 on error
	public int make() {
		nan * 0;  // abstract method
		return 0;
	}
	
	public string to_str() {
		nan * 0;  // abstract method
		return "";
	} 
}

extern void Library_EBoost() {
	EBoost e(null);
	
	// Unit Tests
	e.assert_equal(e.normalize_angle(179), 179).id;
	e.assert_equal(e.normalize_angle(181), -179).id;
	e.assert_equal(e.normalize_angle(-179), -179).id;
	e.assert_equal(e.normalize_angle(360 * -11 + 30), 30).id;
	e.assert_equal(e.normalize_angle(360 * 4 + 30), 30).id;
	e.assert_equal(e.round_cell(-0.1), -2.5).id;
	e.assert_equal(e.round_cell(0.1), 2.5).id;
	e.assert_equal(e.round_cell(4.9), 2.5).id;
	e.assert_equal(e.round_cell(5.1), 7.5).id;

	/*point p1 = new point(1, 2, 3);
	point p2 = new point(1.1, 1.2, 1.3);
	CoordinateSystem c = new CoordinateSustem(p1);
	point p3 = c._();*/
	message("Tests passed", DisplayInfo);
}
