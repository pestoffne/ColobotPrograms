



public class PathPart {
public void PathPart() {
nan * 0;
}

public point from() {
nan * 0;
return new point;
}

public point to() {
nan * 0;
return new point;
}

public float length() {
nan * 0;
return 0;
}

public float time() {
nan * 0;
return 0;
}

public float get_progress(float px, float py) {
nan * 0;
return 0;
}

public float get_progress(point pos) {
nan * 0;
return 0;
}

public float max_progress() {
nan * 0;
return 0;
}

public point get_position(float progress) {
nan * 0;
return new point;
}

public void go(EBoost e) {
nan * 0;
}

public string to_str() {
nan * 0;
return "";
}
}



public class UnaryPredicatePathPart {
void UnaryPredicatePathPart() {
nan * 0;
}

bool _(PathPart value) {
return true;
}
}

public class ListElemPathPart { public void ListElemPathPart(PathPart value , ListElemPathPart prev = null , ListElemPathPart next = null ) { this.value = value; this.prev = prev; this.next = next; } public PathPart value; public ListElemPathPart prev; public ListElemPathPart next; }




public class ListIteratorPathPart {
protected ListElemPathPart _elem;

void ListIteratorPathPart(ListElemPathPart elem) {
this._elem = elem;
}

ListIteratorPathPart copy() {
return new ListIteratorPathPart(this._elem);
}

bool equal(ListIteratorPathPart that) {
return this._elem == that._elem;
}

ListElemPathPart get_elem() {
return this._elem;
}

bool is_null() {
return this._elem == null;
}

PathPart value() {
return this._elem.value;
}

ListIteratorPathPart shift() {
this._elem = this._elem.next;
return this;
}
}

public class ListBackwardIteratorPathPart extends ListIteratorPathPart {
void ListBackwardIteratorPathPart(ListElemPathPart elem) {
super._elem = elem;
}

ListBackwardIteratorPathPart copy() {
return new ListBackwardIteratorPathPart(this._elem);
}

ListIteratorPathPart shift() {
this._elem = this._elem.prev;
return this;
}
}


public class ListPathPart {
private ListElemPathPart _back = null;
private ListElemPathPart _front = null;
private int _size = 0;

void ~ListPathPart() {
this.clear();
}


PathPart back() {
if (this._back == null) {
return null;
}

return this._back.value;
}


PathPart front() {
if (this._front == null) {
return null;
}

return this._front.value;
}

ListIteratorPathPart begin() {
return new ListIteratorPathPart(this._front);
}

ListIteratorPathPart end() {
return new ListIteratorPathPart(null);
}

ListIteratorPathPart rbegin() {
return new ListBackwardIteratorPathPart(this._back);
}

ListIteratorPathPart rend() {
return new ListBackwardIteratorPathPart(null);
}

bool empty() {
return this._back == null;
}

int size() {
return this._size;
}

void clear() {
while (not this.empty()) {
this.pop_back();
}
}


ListIteratorPathPart insert(ListIteratorPathPart pos, PathPart value) {
ListElemPathPart elem_prev, elem_new, elem_next, front_prev;

if (pos.equal(this.end())) {

this.push_back(value);
return new ListIteratorPathPart(this._back);
}

elem_next = pos.get_elem();
elem_prev = elem_next.prev;
elem_new = new ListElemPathPart(value, elem_prev, elem_next);
elem_next.prev = elem_new;

if (elem_prev == null) {
this._front = elem_new;
} else {
elem_prev.next = elem_new;
}

this._size++;
return new ListIteratorPathPart(elem_new);
}

void push_back(PathPart value) {
this._back = new ListElemPathPart(value, _back, null);

if (this._front == null) {
this._front = this._back;
} else {
this._back.prev.next = this._back;
}

this._size++;
}

void pop_back() {
ListElemPathPart elem_prev;

elem_prev = this._back.prev;

if (elem_prev != null) {
elem_prev.next = null;
} else {
this._front = null;
}

this._back = elem_prev;
this._size--;
}

void push_front(PathPart value) {
_front = new ListElemPathPart(value, null, _front);

if (_back == null) {
_back = _front;
} else {
_front.next.prev = _front;
}

this._size++;
}

void pop_front() {
ListElemPathPart elem_next;

elem_next = this._front.next;

if (elem_next != null) {
elem_next.prev = null;
} else {
this._back = null;
}

this._front = elem_next;
this._size--;
}

void _unlink_elem(ListElemPathPart elem_curr) {
ListElemPathPart elem_prev, elem_next;

elem_prev = elem_curr.prev;
elem_next = elem_curr.next;

if (elem_prev == null) {
this._front = elem_next;
} else {
elem_prev.next = elem_next;
elem_curr.prev = null;
}

if (elem_next == null) {
this._back = elem_prev;
} else {
elem_next.prev = elem_prev;
elem_curr.next = null;
}

this._size--;
}


void remove(PathPart value) {
ListIteratorPathPart it1, it2;
ListElemPathPart elem;

if (this.empty()) {
return;
}

it1 = this.begin();
it2 = this.begin().shift();

for (;;) {
elem = it1.get_elem();

if (elem.value == value) {
this._unlink_elem(elem);
}

if (it2.equal(this.end())) {
return;
}

it1 = it2.copy();
it2.shift();
}
}

void remove_if(UnaryPredicatePathPart pred) {
ListIteratorPathPart it1, it2;
ListElemPathPart elem;

if (this.empty()) {
return;
}

it1 = this.begin();
it2 = this.begin().shift();

for (;;) {
elem = it1.get_elem();

if (pred._(elem.value)) {
this._unlink_elem(elem);
}

if (it2.equal(this.end())) {
return;
}

it1 = it2.copy();
it2.shift();
}
}

void unique() {
nan * 0;
}

void sort() {
nan * 0;
}
}

public ListIteratorPathPart list_find(ListIteratorPathPart first, ListIteratorPathPart last, PathPart value) {
ListIteratorPathPart it;

for (it = first.copy(); not it.equal(last); it.shift()) {
if (it.value() == value) {
return it;
}
}

return new ListIteratorPathPart(null);
}

public ListIteratorPathPart list_find_if(ListIteratorPathPart first, ListIteratorPathPart last, UnaryPredicatePathPart pred) {
ListIteratorPathPart it;

for (it = first.copy(); not it.equal(last); it.shift()) {
if (pred._(it.value())) {
return it;
}
}

return new ListIteratorPathPart(null);
}





public class PathNode { public void PathNode(float center_x , float center_y , float radius ) { this.center_x = center_x; this.center_y = center_y; this.radius = radius; } public float center_x; public float center_y; public float radius; }



public class UnaryPredicatePathNode {
void UnaryPredicatePathNode() {
nan * 0;
}

bool _(PathNode value) {
return true;
}
}

public class ListElemPathNode { public void ListElemPathNode(PathNode value , ListElemPathNode prev = null , ListElemPathNode next = null ) { this.value = value; this.prev = prev; this.next = next; } public PathNode value; public ListElemPathNode prev; public ListElemPathNode next; }




public class ListIteratorPathNode {
protected ListElemPathNode _elem;

void ListIteratorPathNode(ListElemPathNode elem) {
this._elem = elem;
}

ListIteratorPathNode copy() {
return new ListIteratorPathNode(this._elem);
}

bool equal(ListIteratorPathNode that) {
return this._elem == that._elem;
}

ListElemPathNode get_elem() {
return this._elem;
}

bool is_null() {
return this._elem == null;
}

PathNode value() {
return this._elem.value;
}

ListIteratorPathNode shift() {
this._elem = this._elem.next;
return this;
}
}

public class ListBackwardIteratorPathNode extends ListIteratorPathNode {
void ListBackwardIteratorPathNode(ListElemPathNode elem) {
super._elem = elem;
}

ListBackwardIteratorPathNode copy() {
return new ListBackwardIteratorPathNode(this._elem);
}

ListIteratorPathNode shift() {
this._elem = this._elem.prev;
return this;
}
}


public class ListPathNode {
private ListElemPathNode _back = null;
private ListElemPathNode _front = null;
private int _size = 0;

void ~ListPathNode() {
this.clear();
}


PathNode back() {
if (this._back == null) {
return null;
}

return this._back.value;
}


PathNode front() {
if (this._front == null) {
return null;
}

return this._front.value;
}

ListIteratorPathNode begin() {
return new ListIteratorPathNode(this._front);
}

ListIteratorPathNode end() {
return new ListIteratorPathNode(null);
}

ListIteratorPathNode rbegin() {
return new ListBackwardIteratorPathNode(this._back);
}

ListIteratorPathNode rend() {
return new ListBackwardIteratorPathNode(null);
}

bool empty() {
return this._back == null;
}

int size() {
return this._size;
}

void clear() {
while (not this.empty()) {
this.pop_back();
}
}


ListIteratorPathNode insert(ListIteratorPathNode pos, PathNode value) {
ListElemPathNode elem_prev, elem_new, elem_next, front_prev;

if (pos.equal(this.end())) {

this.push_back(value);
return new ListIteratorPathNode(this._back);
}

elem_next = pos.get_elem();
elem_prev = elem_next.prev;
elem_new = new ListElemPathNode(value, elem_prev, elem_next);
elem_next.prev = elem_new;

if (elem_prev == null) {
this._front = elem_new;
} else {
elem_prev.next = elem_new;
}

this._size++;
return new ListIteratorPathNode(elem_new);
}

void push_back(PathNode value) {
this._back = new ListElemPathNode(value, _back, null);

if (this._front == null) {
this._front = this._back;
} else {
this._back.prev.next = this._back;
}

this._size++;
}

void pop_back() {
ListElemPathNode elem_prev;

elem_prev = this._back.prev;

if (elem_prev != null) {
elem_prev.next = null;
} else {
this._front = null;
}

this._back = elem_prev;
this._size--;
}

void push_front(PathNode value) {
_front = new ListElemPathNode(value, null, _front);

if (_back == null) {
_back = _front;
} else {
_front.next.prev = _front;
}

this._size++;
}

void pop_front() {
ListElemPathNode elem_next;

elem_next = this._front.next;

if (elem_next != null) {
elem_next.prev = null;
} else {
this._back = null;
}

this._front = elem_next;
this._size--;
}

void _unlink_elem(ListElemPathNode elem_curr) {
ListElemPathNode elem_prev, elem_next;

elem_prev = elem_curr.prev;
elem_next = elem_curr.next;

if (elem_prev == null) {
this._front = elem_next;
} else {
elem_prev.next = elem_next;
elem_curr.prev = null;
}

if (elem_next == null) {
this._back = elem_prev;
} else {
elem_next.prev = elem_prev;
elem_curr.next = null;
}

this._size--;
}


void remove(PathNode value) {
ListIteratorPathNode it1, it2;
ListElemPathNode elem;

if (this.empty()) {
return;
}

it1 = this.begin();
it2 = this.begin().shift();

for (;;) {
elem = it1.get_elem();

if (elem.value == value) {
this._unlink_elem(elem);
}

if (it2.equal(this.end())) {
return;
}

it1 = it2.copy();
it2.shift();
}
}

void remove_if(UnaryPredicatePathNode pred) {
ListIteratorPathNode it1, it2;
ListElemPathNode elem;

if (this.empty()) {
return;
}

it1 = this.begin();
it2 = this.begin().shift();

for (;;) {
elem = it1.get_elem();

if (pred._(elem.value)) {
this._unlink_elem(elem);
}

if (it2.equal(this.end())) {
return;
}

it1 = it2.copy();
it2.shift();
}
}

void unique() {
nan * 0;
}

void sort() {
nan * 0;
}
}

public ListIteratorPathNode list_find(ListIteratorPathNode first, ListIteratorPathNode last, PathNode value) {
ListIteratorPathNode it;

for (it = first.copy(); not it.equal(last); it.shift()) {
if (it.value() == value) {
return it;
}
}

return new ListIteratorPathNode(null);
}

public ListIteratorPathNode list_find_if(ListIteratorPathNode first, ListIteratorPathNode last, UnaryPredicatePathNode pred) {
ListIteratorPathNode it;

for (it = first.copy(); not it.equal(last); it.shift()) {
if (pred._(it.value())) {
return it;
}
}

return new ListIteratorPathNode(null);
}
public class PathArc extends PathPart {
public float from_x, from_y, to_x, to_y, center_x, center_y, radius, from_angle, to_angle, max_progress;
public PolarCoordinateSystem cs;
}

public void PathArc::PathArc(float from_x, float from_y, float to_x, float to_y,
float center_x, float center_y, float radius) {
this.from_x = from_x;
this.from_y = from_y;
this.to_x = to_x;
this.to_y = to_y;
this.center_x = center_x;
this.center_y = center_y;
this.radius = abs(radius);
this.from_angle = ( (this.from_x - this.center_x) > 0 ? atan((this.from_y - this.center_y) / (this.from_x - this.center_x)) : (this.from_x - this.center_x) < 0 ? atan((this.from_y - this.center_y) / (this.from_x - this.center_x)) + 180 : ((this.from_y - this.center_y) > 0 ? 90 : -90) );
this.to_angle = ( (this.to_x - this.center_x) > 0 ? atan((this.to_y - this.center_y) / (this.to_x - this.center_x)) : (this.to_x - this.center_x) < 0 ? atan((this.to_y - this.center_y) / (this.to_x - this.center_x)) + 180 : ((this.to_y - this.center_y) > 0 ? 90 : -90) );
this.max_progress = (3.14159265359 * abs(to_angle - from_angle) * (radius) / 180);
this.cs = new PolarCoordinateSystem(
center_x, center_y, from_angle, ((to_angle - from_angle) > 0 ? 1 : -1));
}

public point PathArc::from() {
return new point(this.from_x, this.from_y);
}

public point PathArc::to() {
return new point(this.to_x, this.to_y);
}

public float PathArc::length() {
return (3.14159265359 * abs(this.to_angle - this.from_angle) * (this.radius) / 180);
}

public float PathArc::time() {
return (3.14159265359 * abs(this.to_angle - this.from_angle) * (this.radius) / 180)
/ ((((1 - 2 / ((this.radius) + 1))) + (1)) * 2.5);
}

public float PathArc::get_progress(float px, float py) {
return (3.14159265359 * abs(this.cs.s(px, py).angle) * (this.radius) / 180);
}

public float PathArc::get_progress(point pos) {
return (3.14159265359 * abs(this.cs.s(pos).angle) * (this.radius) / 180);
}

public float PathArc::max_progress() {
return this.max_progress;
}

public point PathArc::get_position(float progress) {
return this.cs.i(progress, this.radius);
}

public void PathArc::go(EBoost e) {
nan * 0;
}

public string PathArc::to_str() {

return "PathArc(center_x=" + (round((center_x) * 100) / 100) + ", center_y=" + (round((center_y) * 100) / 100)
+ ", radius=" + (round((radius) * 100) / 100)
+ ", from_angle=" + (round((from_angle) * 100) / 100) + ", to_angle=" + (round((to_angle) * 100) / 100)
+ ", from_x=" + (round((from_x) * 100) / 100) + ", from_y=" + (round((from_y) * 100) / 100)
+ ", to_x=" + (round((to_x) * 100) / 100) + ", to_y=" + (round((to_y) * 100) / 100)
+ ", length=" + (round((length()) * 100) / 100) + ", time=" + (round((time()) * 100) / 100) + ")";






}






public class PathLine extends PathPart {
public float from_x, from_y, to_x, to_y, max_progress;
public AffineCoordinateSystem2D css, csi;
}

public void PathLine::PathLine(float from_x, float from_y, float to_x, float to_y) {
this.from_x = from_x;
this.from_y = from_y;
this.to_x = to_x;
this.to_y = to_y;
this.max_progress = sqrt(pow((from_x) - (to_x), 2) + pow((from_y) - (to_y), 2));
this.css = coordinate_system_from_2_points_2d(from_x, from_y, to_x, to_y);
this.csi = css.inverse();
}

public point PathLine::from() {
return new point(from_x, from_y);
}

public point PathLine::to() {
return new point(to_x, to_y);
}

public float PathLine::length() {
return sqrt(pow((from_x) - (to_x), 2) + pow((from_y) - (to_y), 2));
}

public float PathLine::time() {
return sqrt(pow((from_x) - (to_x), 2) + pow((from_y) - (to_y), 2)) / 5;
}

public float PathLine::get_progress(float px, float py) {
return this.css._(px, py).x;
}

public float PathLine::get_progress(point pos) {
return this.css._(pos).x;
}

public float PathLine::max_progress() {
return this.max_progress;
}

public point PathLine::get_position(float progress) {
return this.csi._(progress, 0);
}

public void PathLine::go(EBoost e) {
nan * 0;
}

public bool eq(PathLine a, PathLine b) {
return a.from_x == b.from_x
and a.from_y == b.from_y
and a.to_x == b.to_x
and a.to_y == b.to_y;
}

public bool almost_equal(PathLine a, PathLine b) {
return abs(a.from_x - b.from_x) < 0.001
and abs(a.from_y - b.from_y) < 0.001
and abs(a.to_x - b.to_x) < 0.001
and abs(a.to_y - b.to_y) < 0.001;
}

public string PathLine::to_str() {

return "PathLine(from_x=" + (round((from_x) * 100) / 100) + ", from_y=" + (round((from_y) * 100) / 100)
+ ", to_x=" + (round((to_x) * 100) / 100) + ", to_y=" + (round((to_y) * 100) / 100)
+ ", length=" + (round((length()) * 100) / 100) + ", time=" + (round((time()) * 100) / 100) + ")";




}

public PathLine tangent_line(PathNode c1, PathNode c2) {
AffineCoordinateSystem2D cs; point p1, p2; float dist, pm, mp, from_x, from_y, to_x, to_y;

dist = sqrt(pow((c1.center_x) - (c2.center_x), 2) + pow((c1.center_y) - (c2.center_y), 2));


from_x = (pow(c1.radius, 2) - c1.radius * c2.radius) / dist;
from_y = sqrt(pow(c1.radius, 2) - pow(from_x, 2)) * ((c1.radius) > 0 ? 1 : -1);
to_x = (pow(dist, 2) + c1.radius * c2.radius - pow(c2.radius, 2)) / dist;
to_y = sqrt(pow(c2.radius, 2) - pow(to_x - dist, 2)) * ((c2.radius) > 0 ? 1 : -1);

cs = coordinate_system_from_2_points_2d(c1.center_x, c1.center_y, c2.center_x, c2.center_y);
p1 = cs._(from_x, from_y);
p2 = cs._(to_x, to_y);
return new PathLine(p1.x, p1.y, p2.x, p2.y);
}





public class PathCompiled {
private ListPathPart _list;

public void PathCompiled(ListPathPart list) {
this._list = list;
}

public float length() {
ListIteratorPathPart it; float sum;

sum = 0;

for (it = this._list.begin(); not it.is_null(); it.shift()) {
sum += it.value().length();
}

return sum;
}

public float time() {
ListIteratorPathPart it; float sum;

sum = 0;

for (it = this._list.begin(); not it.is_null(); it.shift()) {
sum += it.value().time();
}

return sum;
}

public void go(EBoost e) {
ListIteratorPathPart it;

for (it = this._list.begin(); not it.is_null(); it.shift()) {
it.value().go(e);
}
}

public void debug_dump(string filename) {
ListIteratorPathPart it; file f;

f = new file();
f.open(filename, "w");

for (it = this._list.begin(); not it.is_null(); it.shift()) {
f.writeln(it.value().to_str());
}

f.close();
}
}
public class Path {
private ListPathNode _list_nodes;
private PathCompiled _path_compiled;
private point _start;

public void Path(point start) {
this._start = start;
this._list_nodes = new ListPathNode();
}

public Path add_node(point center, float radius) {

this._list_nodes.push_back(new PathNode(center.x, center.y, radius));
return this;
}
public Path compile() {
ListPathPart list_parts; ListIteratorPathNode it1, it2; PathLine line; float px, py;

list_parts = new ListPathPart();

it1 = this._list_nodes.begin();
it2 = it1.copy().shift();
px = this._start.x;
py = this._start.y;

while (not it2.is_null()) {
line = tangent_line(it1.value(), it2.value());
list_parts.push_back(new PathArc(
px, py, line.from_x, line.from_y,
it1.value().center_x, it1.value().center_y, it1.value().radius
));
list_parts.push_back(line);

px = line.to_x;
py = line.to_y;
it1.shift();
it2.shift();
}

this._list_nodes = null;
this._path_compiled = new PathCompiled(list_parts);
return this;
}

public float length() {
return this._path_compiled.length();
}

public float time() {
return this._path_compiled.time();
}

public void go(EBoost e) {
this._path_compiled.go(e);
}

public void debug_dump(string filename="debug_dump_path.txt") {
this._path_compiled.debug_dump(filename);
}
}

public class MoveArcFunctionVV extends FunctionVV {
private EBoost _e;

public void MoveArcFunctionVV(EBoost e) {
this._e = e;
}

public void _() {
AffineCoordinateSystem2D css; Path path;

css = coordinate_system_from_matrix_2d(new Matrix_float(3, 2, matrix_values(
0, 5, 79.25,
-5, 0, -55.25
)));



point pos = this._e.actor.position;
pos.y += 1.75;
path = new Path(this._e.actor.position)
.add_node(pos, -1.75)



.add_node(css._(5, 5), -1.75)
.add_node(css._(2, 5), -1.75)
.add_node(css._(1, 4), -1.75)
.add_node(css._(1, 1), -1.75)
.add_node(css._(3, 0), 1.75)
.add_node(css._(3.35, 0), 0)
.compile();

message("length = " + path.length() + ", expected range from 68.86 to 92.5");
message("time = " + path.time() + ", expected range from about 16 to 27");
path.debug_dump("debug_dump_pathX.txt");

}
}

extern void object::MoveLabirint()
{
float time;
EBoost e(this);


time = e.benchmark(new MoveArcFunctionVV(e));



}
