//-Shared-------------------------------------------------------------------------------------------//

float Round(float value, int digits) {
	int a = pow(10, digits);
	return round(value * a) / a;
}

float random(float min, float max) {
	return rand() * (max - min) + min;
}

point sum(point a, point b) {
	point c;
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	c.z = a.z + b.z;
	return c;
}

point mul(point a, float b) {
	point c;
	c.x = a.x * b;
	c.y = a.y * b;
	c.z = a.z * b;
	return c;
}

void log(string text) {
	file handle = new file();
	handle.open("cb_log_pl.txt", "a");
	handle.writeln(Round(abstime(), 1) + " " + text);
	handle.close();
}

object RadarWait(int cat, float wait_time, int angle=0, int focus=360, int min=0, int max=1000, int sens=1, int filter=FilterNone) {
	object item;
	
	for (;;) {
		item = radar(cat, angle, focus, min, max, sens, filter);
		
		if (item != null) {
			break;
		}
		
		if (wait_time <= 0) {
			return null;
		}
		
		wait(0.1);
		wait_time -= 0.1;
	}
	
	return item;
}

object RadarFriendly(int cat=Any, float angle=0, float focus=360, float min=0, float max=1000, float sens=1) {
	return RadarWait(cat, 15.5, angle, focus, min, max, sens, FilterFriendly);
}

object RadarEnemy(int cat=Any, float angle=0, float focus=360, float min=0, float max=1000, float sens=1) {
	return RadarWait(cat, 15.5, angle, focus, min, max, sens, FilterEnemy);
}

void object::WaitPowerCell() {
	while (energyCell == null) {
		wait(0.1);
	}
	turn(180);
	wait(3);
	move(4);
	jet(1);
	wait(1.5);
}

int object::GotoR(point pos, int retries=5) {  // failsafe
	for (;retries > 0; --retries) {
		if (goto(pos) == 0) {
			return 0;
		}
		
		wait(1);
	}
	
	return 1;
}

bool object::CheckEnergyCell(float min_energy=0.2) {  // failsafe
	object item;
	
	if (energyCell.energyLevel > min_energy) {
		return false;
	}
	
	item = radar(PowerStation);
	
	if (item == null) {
		return false;
	}
	
	GotoR(item.position);
	
	while (energyCell != null and energyCell.energyLevel < 1) {
		wait(0.1);
	}
	
	return true;
}

int object::GotoGrab(int cat, float wait_time=10, int retries=5, float angle=0, float focus=360, float min=0, float max=1000, float sens=1) {  // unsafe
	object item; int ret;
	
	for (; retries > 0; --retries) {
		if (load != null) {
			if (load.category == cat) {
				return 0;
			}
		}
		
		for (;;) {
			item = radar(cat, angle, focus, min, max, sens);
			
			if (item != null) {
				break;
			}
			
			if (wait_time > 0) {
				wait_time -= 0.1;
				wait(0.1);
			} else {
				return 1;
			}
		}
		
		if (load != null) {
			goto(space(position));
			ret = drop();
			
			if (ret != 0) {
				continue;
			}
		}
		
		ret = goto(item.position);
		
		if (ret != 0) {
			continue;
		}
		
		ret = grab();
		
		if (ret != 0 or load.category != cat) {
			continue;
		}
	}
	
	return 1;
}

//-WingedGrubber------------------------------------------------------------------------------------//

public bool object::HasEnergyCellSlot() {
	return false
	or category == PracticeBot
	or category == TargetBot
	or category == WheeledGrabber
	or category == TrackedGrabber
	or category == WingedGrabber
	or category == LeggedGrabber
	or category == WheeledSniffer
	or category == TrackedSniffer
	or category == WingedSniffer
	or category == LeggedSniffer
	or category == WheeledShooter
	or category == TrackedShooter
	or category == WingedShooter
	or category == LeggedShooter
	or category == WheeledOrgaShooter
	or category == TrackedOrgaShooter
	or category == WingedOrgaShooter
	or category == LeggedOrgaShooter
	or category == Subber
	or category == Recycler
	or category == Shielder
	or category == Thumper
	or category == PhazerShooter
	or category == ResearchCenter
	or category == DefenseTower
	or category == AutoLab
	or category == PowerPlant
	or category == NuclearPlant
	;
}

public void object::Sabotage() {  // failsafe
	object items[]; int i;
	errmode(0);
	
	WaitPowerCell();
	
	// Sabotage A: Block enemy's single Convertor
	items = radarall(Converter, 0, 360, 0, 1024, 1, FilterEnemy);
	
	if (sizeof(items) == 1) {
		GotoR(items[0].position);
		grab();  // may be Titanium inside
		move(1);
		turn(180);
	}
	
	while (sizeof(items) == 1) {
		wait(1);
		items = radarall(Converter, 0, 360, 0, 1024, 1, FilterEnemy);
	}
	
	// Sabotage B: Block enemy's single BotFactory
	items = radarall(BotFactory, 0, 360, 0, 1024, 1, FilterEnemy);
	
	if (sizeof(items) == 1) {
		GotoR(items[0].position);
		grab();  // may be Titanium inside
		// TODO: may be a enemy's Bot inside
		move(1);
		turn(180);
	}
	
	while (sizeof(items) == 1) {
		wait(1);
		items = radarall(BotFactory, 0, 360, 0, 1024, 1, FilterEnemy);
	}
	
	// Sabotage C: Insert TitaniumOres into empty energyCells
	for (;;) {
		CheckEnergyCell();
		
		items = radarall(Any, 0, 360, 0, 1024, -1, FilterEnemy);
		for (i = sizeof(items) - 1; i >= 0; --i) {
			if (items[i].HasEnergyCellSlot()) {
				if (items[i].energyCell == null) {
					GotoGrab(TitaniumOre);
					GotoR(items[i].position);
					drop();
					break;
				} else if (items[i].energyCell.category != TitaniumOre) {
					GotoGrab(TitaniumOre);
					GotoR(items[i].position);
					Replace();
					break;
				}
			} else if (items[i].category == BotFactory) {
				GotoGrab(TitaniumOre);
				GotoR(items[i].position);
				drop();
				break;
				// TODO: replace
			} else if (items[i].category == Converter) {
				GotoGrab(PowerCell);
				GotoR(items[i].position);
				drop();
				break;
			}
		}
	}
}

//-WingedShooter------------------------------------------------------------------------------------//

float object::AbsMin(float a, float b) {
	if (abs(a) < abs(b)) {
		return a;
	}
	
	return b;
}

public void object::HuntGround() {
	object item; point pos;
	errmode(0);
	
	WaitPowerCell();
	
	for (;;) {
		// TODO: use emeny's PowerStation
		// TODO: replace hardcoded coordinates
		pos.x = random(-25, 25);
		pos.y = random(30, 80);
		
		pos = flatspace(pos, 2, 0, 20, 0.5);
		goto(pos);
		
		for (int tick = 0;; ++tick) {
			
			item = RadarEnemy();
			
			if (item == null) {
				message("Hunt is complete");
				return;
			}
			
			turn(direction(item.position));
			item = radar(Any, 0, 360, 0, 30, 1, FilterEnemy);
			
			if (item != null) {
				float ay = atan((item.position.z - position.z - 1.5)
				            / distance2d(item.position, position))
				            - AbsMin(pitch, pitch - 360);
				float bx = ay * sin(roll);
				float by = ay * cos(roll);
				bool can_aim = bx >= -45 and bx <= 45 and by >= -20 and by <= 20;
				
				if (can_aim) {
					aim(by, bx);
					fire(0.1);
				}
			} else {
				motor(1, 1);
				wait(0.1);
			}
			
			if (CheckEnergyCell(0.33)) {
				break;
			}
		}
	}
}

//-WheeledGrabber-----------------------------------------------------------------------------------//

public bool object::IsEmpty() {
	object item; float min_distance;
	
	if (category == Converter) {
		min_distance = 2.0;
	} else if (category == BotFactory) {
		min_distance = 5.0;
	} else {
		return true;
	}
	
	for (int j = 0;; ++j) {
		item = retobject(j);
		
		if (item == null) {
			break;
		}
		
		if (category == item.category) {
			continue;
		}
		
		if (distance(position, item.position) < min_distance) {
			return false;
		}
	}
	
	return true;
}

object RadarEmptyFriendly(int cat) {
	object[] items;
	items = radarall(cat, 0, 360, 0, 1000, -1, FilterFriendly);
	
	for (int i = sizeof(items) - 1; i >= 0; --i) {
		if (items[i].IsEmpty()) {
			return items[i];
		}
	}
	
	return null;
}

int object::fill_q(point pos, int cat) {
	object item;
	
	goto_p(pos, 5.5);
	item = RadarFriendly(cat);
	
	if (item == null) {
		log("warning fill_q failed to find Bot, timeout expired");
		return 1;
	}
	
	goto(item.position);
	drop();
	
	if (load != null or item.energyCell == null) {
		log("warning fill_q failed to insert PowerCell");
		return 1;
	}
	
	move(-1.5);
	return 0;
}

void Replace() {
	/*
	                    turn(120);  drop();
	turn(-120); grab(); turn(-120); drop();
	turn(-120); grab(); turn(120);  drop();
	turn(-120); grab();
	*/
	drop(Behind);
	grab();
	turn(90);
	drop();
	turn(-90);
	grab(Behind);
	drop();
	turn(90);
	grab();
}

void switch_powercell() {
	///*
	grab(EnergyCell); drop(Behind);
	grab();           drop(EnergyCell);
	grab(Behind);
	//*/
	/*
	grab();           drop(Behind);
	grab(EnergyCell); drop();
	grab(Behind);     drop(EnergyCell);
	grab();
	//*/
}

void object::turn_q(float angle) {
	if (angle < -180) {
		angle += 360;
	} else if (angle > 180) {
		angle -= 360;
	}
	
	turn(angle);
}

// Expect direct >= 0, 90 is Nord direction
void object::orient(float direct) {
	direct -= orientation;
	turn_q(direct);
}

int object::build_q(point pos, int cat) {
	if (goto_p(pos) == 0 and drop() == 0 and build(cat) == 0) {
		return 0;
	}
	
	return 1;
}

int object::factory_q(point bot_factory_pos, int bot_cat, string program) {
	object item;
	
	goto_p(bot_factory_pos, 5);
	move(2.5);
	drop();
	move(-2.5);
	item = radar(BotFactory, 0, 15, 0, 10);
	
	if (item == null) {
		log("warning factory_q BotFactory not found");
		return 1;
	}
	
	while (item.factory(bot_cat, program) != 0) {
		wait(1);
	}
	
	return 0;
}

int object::goto_q(point pos, float dist=1.5, int oper=InFront) {
	if (oper == InFront) {
		turn(direction(pos));
		move(distance2d(position, pos) - dist);
	} else if (oper == Behind) {
		turn_q(direction(pos) + 180);
		move(dist - distance2d(position, pos));
	} else {
		log("error goto_q unexpected oper value = " + oper);
		return 2;
	}
	
	if (distance2d(pos, position) > dist + 1) {
		log("warning goto_q i am not in the expecter place, distance = " + distance2d(pos, position));
		return 1;
	}
	
	return 0;
}

int object::goto_pp(point pos, float direct, float dist=1.5, int oper=InFront) {
	point pos_bot;
	
	pos_bot.x = pos.x - cos(direct) * dist;
	pos_bot.y = pos.y - sin(direct) * dist;
	
	goto_q(pos_bot, 0, oper);
	
	if (oper == InFront) {
		orient(direct);
	} else {
		orient(180 + direct);
	}
	
	return 0;
}

int object::goto_p(point pos, float dist=1.5, int oper=InFront) {
	return goto_pp(pos, pos.z, dist, oper);
}

void object::make_titaniums_1_2(float direct=270, int oper=InFront) {
	Globals g();
	
	goto_q(g.b.derrick_out);
	grab_from_ground(TitaniumOre);
	goto_q(g.b.converter_1, 1.9);
	drop();
	goto_q(g.b.derrick_out, 1.5, Behind);
	grab_from_ground(TitaniumOre, Behind);
	goto_q(g.b.converter_2, 1.9);
	drop();
	goto_pp(g.b.converter_1, direct, 1.5, oper);
	grab_from_ground(Titanium, oper);
}

void object::get_out_power_cell(point pos, float inc) {
	if (load == null) {
		return;
	}
	
	// TODO: check position first, before drop try
	for (;;) {
		goto_q(pos);
		
		if (drop() == 0) {
			break;
		}
		
		pos.x += inc;
	}
}

int object::research_q(int res_cat) {
	object item;
	Globals g();
	
	if (load == null or load.category != PowerCell) {
		log("warning research_q PowerCell is not loaded");
		return 1;
	}
	
	item = RadarFriendly(ResearchCenter);
	
	if (item == null) {
		log("warning research_q ResearchCenter not found");
		return 1;
	}
	
	goto_p(g.b.research_center, 4);
	
	if (item.energyCell == null) {
		drop();
		
		if (item.research(res_cat) != 0) {
			log("warning research_q can not start research");
			return 1;
		}
	} else {
		log("info research_q energyCell slot is not empty. replacing");
		drop(Behind);
		grab_from_energy_cell(PowerCell, ResearchCenter);
		turn(90);
		drop();
		turn(-90);
		grab_from_ground(PowerCell, Behind);
		drop();
		
		if (item.research(res_cat) != 0) {
			log("warning research_q can not start research");
			return 1;
		}
		
		turn(90);
		grab_from_ground(PowerCell);
		// We do not need to get out of PowerCell if we do just 2 or 3 researchers
		// get_out_power_cell(g.b.empty_power_cell, 1);
	}
	
	return 0;
}

// return 0 OK
//        1 another item is loaded
//        2 there is not item to grab
int object::grab_from_ground(int cat, int oper=InFront) {
	float max_wait;
	
	if (load != null) {
		if (load.category == cat) {
			log("warning grab_from_ground needed item is already loaded before grab");
			return 0;
		} else {
			log("warning grab_from_ground another item is already loaded before grab");
			return 1;
		}
	}
	
	if (cat == Titanium) {
		max_wait = 15.5;
	} else if (cat == TitaniumOre) {
		max_wait = 10.5;
	} else {
		max_wait = 0.5;
	}
	
	if (oper == InFront) {
		if (RadarWait(cat, max_wait, 0, 30, 0, 6) == null) {
			log("warning grab_from_ground can not find expected object in front -- timeout expired");
			return 2;
		}
	} else if (oper == Behind) {
		if (RadarWait(cat, max_wait, 180, 30, 0, 6) == null) {
			log("warning grab_from_ground can not find expected object behind -- timeout expired");
			return 2;
		}
	} else {
		log("error grab_from_ground unexpected oper value = " + oper);
		return 3;
	}
	
	grab(oper);
	
	if (load == null) {
		log("warning grab_from_ground load is null after grab");
		return 1;
	}
	
	if (load.category != cat) {
		log("warning grab_from_ground load.category has unexpected value");
		return 1;
	}
	
	return 0;
}

int object::grab_from_energy_cell(int item_cat, int container_cat) {
	object container; float wait_time;
	
	if (load != null) {
		if (load.category == item_cat) {
			log("warning grab_from_energy_cell needed item is already loaded before grab");
			return 0;
		} else {
			log("warning grab_from_energy_cell another item is already loaded before grab");
			return 1;
		}
	}
	
	if (container_cat == PowerPlant) {
		wait_time = 22.5;
	} else {
		wait_time = 0.5;
	}
	
	for (;;) {
		container = radar(container_cat, 0, 30, 0, 10);
		
		if (container == null) {
			log("warning grab_from_energy_cell can not find container grab from");
			return 1;
		}
		
		if (container.energyCell != null and container.energyCell.category == item_cat) {
			break;
		}
		
		if (wait_time <= 0) {
			log("warning grab_from_energy_cell can not find item to grab, timeout expired");
			return 1;
		}
		
		wait(0.1);
		wait_time -= 0.1;
	}
	
	grab();
	
	if (load == null) {
		log("warning grab_from_energy_cell load is null after grab");
		return 1;
	}
	
	if (load.category != item_cat) {
		log("warning grab_from_energy_cell load.category has unexpected value");
		return 1;
	}
	
	return 0;
}

public class BasePlan {
	static point derrick_out, converter_1, converter_2, power_plant, bot_factory, research_center, titanium_ore, empty_power_cell;
	
	void BasePlan() {
		// triangle(10, 7, 7) with p = 24
		derrick_out.x = 0;
		derrick_out.y = -55.5;
		derrick_out.z = 270;
		converter_1.x = 5;
		converter_1.y = -50.5;
		converter_1.z = 315;
		converter_2.x = -5;
		converter_2.y = -50.5;
		converter_2.z = 225;
		titanium_ore.x = 3;
		titanium_ore.y = -54.5;
		titanium_ore.z = 315;
		power_plant.x = 5;
		power_plant.y = -44;
		power_plant.z = 0;
		bot_factory.x = -8;
		bot_factory.y = -42;
		bot_factory.z = 180;
		research_center.x = 5;
		research_center.y = -36;
		research_center.z = 90;
		empty_power_cell.x = 5;
		empty_power_cell.y = -39;
		empty_power_cell.z = 0;
	}
}

public class Globals {
	//public static BasePlan b = new BasePlan();  // crash game
	public static BasePlan b = null;
	
	void Globals() {
		b = new BasePlan();
	}
}

void object::setup() {
	object item; point pos;
	Globals g();
	
	grab_from_ground(Titanium);
	build_q(g.b.converter_1, Converter);
	log("info setup Converter_1");
	
	goto_q(g.b.derrick_out);
	grab_from_ground(TitaniumOre);
	goto_q(g.b.converter_1, 2);
	drop();
	goto_q(g.b.derrick_out, 1.5, Behind);
	grab_from_ground(TitaniumOre, Behind);
	goto_p(g.b.titanium_ore);
	drop();
	goto_pp(g.b.converter_1, 350, 2);
	grab_from_ground(Titanium);
	build_q(g.b.converter_2, Converter);
	log("info setup Converter_2");
	
	make_titaniums_1_2(285, Behind);
	build_q(g.b.power_plant, PowerPlant);
	log("info setup PowerPlant");
	goto_q(g.b.converter_2, 2);
	grab_from_ground(Titanium);
	build_q(g.b.bot_factory, BotFactory);
	log("info setup BotFactory");
	
	make_titaniums_1_2(275, Behind);
	goto_q(g.b.power_plant);
	drop();
	goto_q(g.b.converter_2);
	grab_from_ground(Titanium);
	build_q(g.b.research_center, ResearchCenter);
	log("info setup ResearchCenter");
	//goto_q(g.b.power_plant);
	orient(270);
	grab_from_energy_cell(PowerCell, PowerPlant);
	research_q(ResearchWinged);
	
	make_titaniums_1_2(275, Behind);
	goto_q(g.b.power_plant);
	drop();
	goto_q(g.b.converter_2);
	grab_from_ground(Titanium);
	factory_q(g.b.bot_factory, WingedGrabber, "Sabotage");
	goto_p(g.b.power_plant);
	grab(EnergyCell);
	drop(Behind);
	grab_from_energy_cell(PowerCell, PowerPlant);
	drop(EnergyCell);
	turn(180);
	grab_from_ground(PowerCell);
	fill_q(g.b.bot_factory, WingedGrabber);
	log("info setup WingedGrabber");
	
	// --- unsafe line ---
	
	make_titaniums_1_2(275, Behind);
	goto_q(g.b.power_plant);
	drop();
	orient(180);
	move(3);
	orient(90);
	move(3);
	goto_p(g.b.research_center, 4);
	grab_from_energy_cell(PowerCell, ResearchCenter);
	turn(-90);
	drop();
	goto_q(g.b.power_plant);
	grab_from_energy_cell(PowerCell, PowerPlant);
	research_q(ResearchShooter);
	goto_q(g.b.converter_2);
	grab_from_ground(Titanium);
	goto_q(g.b.power_plant);
	drop();
	
	make_titaniums_1_2();
	factory_q(g.b.bot_factory, WingedShooter, "HuntGround");
	goto_q(g.b.power_plant);
	grab_from_energy_cell(PowerCell, PowerPlant);
	fill_q(g.b.bot_factory, WingedShooter);
	log("info setup WingedShooter");
}

void object::loop() {
	
}

extern void object::cb_1() {
	errmode(0);
	setup();
	
	for (;;) {
		loop();
	}
}
