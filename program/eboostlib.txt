public class RadarArgs {
	int[] cat;
	float angle;
	float focus;
	float min;
	float max;
	float sens;
	int filter;
	
	void RadarArgs(int[] cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		this.cat = cat;
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
	
	void RadarArgs(int cat, float angle=0, float focus=360, float min=0,
	               float max=1024, float sens=1, int filter=FilterNone) {
		EBoost e(null);
		
		this.cat = e.to_list(cat);
		this.angle = angle;
		this.focus = focus;
		this.min = min;
		this.max = max;
		this.sens = sens;
		this.filter = filter;
	}
}

public class EBoost {
	object actor;
	static string logfile = "common_logs.txt";
	
	void EBoost(object actor) {
		this.actor = actor;
		errmode(0);
	}
	
	int another_team() {
		return 3 - actor.team;
	}
	
	object assert(bool value, string text="assertion error") {
		if (value) {
			return retobject(0);
		}
		
		message(text, DisplayError);
		return null;
	}
	
	bool can_load(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber
		or cat == Subber
		or cat == Me
		or cat == AlienWasp;
	}
	
	bool can_switch_own_cell(int cat) {
		return false
		or cat == WheeledGrabber
		or cat == TrackedGrabber
		or cat == WingedGrabber
		or cat == LeggedGrabber;
	}
	
	float _get_energy_level(object item) {
		if (item.category == PowerCell) {
			return item.energyLevel;
		}
		
		if (item.category == NuclearCell) {
			return item.energyLevel * 10;
		}
		
		assert(false, "_get_energy_level of non cell").id;
		return 0;  // never executes
	}
	
	int check_energy(float need_energy=0.33) {
		// Charge methods priorities
		// 1) Goto PowerStation [only PowerCell]
		// 2) Goto switch cell  [only Grabbers]
		// 3) Goto PowerCaptor  [only PowerCell]
		// 4) Ask for help
		object item;
		
		if (actor.energyCell == null
		            or actor.energyCell.category != PowerCell
		           and actor.energyCell.category != NuclearCell) {
			return 1;
		}
		
		if (_get_energy_level(actor.energyCell) >= need_energy) {
			return 0;  // Energy level is already ok
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station() == 0) {
				return 0;
			}
		}
		
		if (can_switch_own_cell(actor.category)) {
			if (go_switch_cell() == 0) {
				return 0;
			}
		}
		
		if (actor.energyCell.category == PowerCell) {
			if (go_power_station(PowerCaptor, 180.0) == 0) {
				return 0;
			}
		}
		
		return 1;
	}
	
	void check_energy_loop(float need_energy=0.33) {
		bool first;
		
		first = true;
		
		for (;;) {
			if (check_energy(need_energy) == 0) {
				return;
			}
			
			if (first) {
				message("I need help with charge", DisplayWarning);
			}
			
			wait(1);
			first = false;
		}
	}
	
	int check_shield(float need_shield=0.5) {
		object item;
		
		if (actor.shieldLevel >= need_shield) {
			return 0;
		}
		
		return go_repair();
	}
	
	bool contains(int[] list, int value) {
		for (int i = 0; i < sizeof(list); ++i) {
			if (list[i] == value) {
				return true;
			}
		}
		
		return false;
	}
	
	void dock_to_ship() {
		point ship_pos; point[] slots; point slot; int i;
		
		ship_pos = radar(SpaceShip).position;
		
		// create list of slots. better to do it staticaly
		i = 0;
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 2.5,  90);
		slots[i++] = new point(ship_pos.x - 4.00, ship_pos.y - 4.0, 150);
		slots[i++] = new point(ship_pos.x - 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 4.00, ship_pos.y - 4.0,  30);
		slots[i++] = new point(ship_pos.x + 2.50, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x - 0.75, ship_pos.y - 4.0,  90);
		slots[i++] = new point(ship_pos.x + 0.75, ship_pos.y - 4.0,  90);
		
		for (i = 0; i < sizeof(slots); ++i) {
			slot = slots[i];
			
			if (search(Any, slot, 0, 1.3) == null) {
				goto_p(slot, 2);
				move(0.5);
				
				if (drop() == 0) {
					break;
				}
			}
		}
	}
	
	void drop_to_helix(point p) {
		int s;
		
		s = 2;
		p.z = 270;  // angle
		
		for (int l = 1; l <= 7; ++l) {
			for (int i = 0; i < l; ++i) {
				p.x += s;
				
				if (_helix_helper(p)) {
					return;
				}
			}
			
			s *= -1;
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
			
			for (int i = 0; i < l; ++i) {
				p.y += s;
				
				if (_helix_helper(p)) {
					return;
				}
			}
			
			p.z += -90;
			
			if (p.z < 0) {
				p.z += 360;
			}
		}
	}
	
	point fire_position(object item) {
		point pos;
		
		pos = item.position;
		
		if (item.category == PowerStation or item.category == Converter) {
			pos.x -= cos(item.orientation) * 2.5;
			pos.y -= sin(item.orientation) * 2.5;
		}
		
		return pos;
	}
	
	float get_height(int cat) {
		float h;
		
		if (cat == Derrick) { h = 35;
		} else if (cat == BotFactory) { h = 28;
		} else if (cat == RepairCenter) { h = 30;
		} else if (cat == PowerStation) { h = 13;
		} else if (cat == Converter) { h = 20;
		} else if (cat == DefenseTower) { h = 30;
		} else if (cat == ResearchCenter) { h = 22;
		} else if (cat == RadarStation) { h = 19;
		} else if (cat == PowerPlant) { h = 20;
		} else if (cat == AutoLab) { h = 16;
		} else if (cat == NuclearPlant) { h = 40;
		} else if (cat == ExchangePost) { h = 19;
		} else {
			return 1.5;  // Assume it is Bot
		}
		
		return h * 0.25;
	}
	
	// return 0 -- PowerCell was recharged
	//        1 -- failed to recharge on PowerStation
	int go_power_station(int cat=PowerStation, float wait_time=15.5) {
		object item;
		
		for (;;) {
			item = radar(cat);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(cat, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.energyCell == null or actor.energyCell.category != PowerCell) {
					return 1;
				}
				
				if (actor.energyCell.energyLevel > 0.95) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_repair() {
		object item; float wait_time;
		
		for (;;) {
			item = radar(RepairCenter);
			
			if (item == null) {
				return 1;
			}
			
			goto(item.position);
			wait_time = 15.5;
			
			for (;;) {
				if (distance2d(item.position, actor.position) > 1.0) {
					turn(direction(item.position));
					motor(1, 1);
				}
				
				wait(0.1);
				wait_time -= 0.1;
				
				if (wait_time <= 0) {
					return 1;
				}
				
				item = radar(RepairCenter, 0, 360, 0, 10);
				
				if (item == null) {
					break;  // PowerStation is loosed. Let's find another
				}
				
				if (actor.shieldLevel >= 1) {
					return 0;
				}
			}
		}
		
		return 1;  // never executes
	}
	
	int go_switch_cell() {
		object item;
		
		if (not can_switch_own_cell(actor.category)) {
			return 1;
		}
		
		item = radar_best_cell(0, 360, 0, 50);
		
		if (item == null) {
			return 1;
		}
		
		goto(item.position);
		switch_cell();
		return 0;
	}
	
	int goto_grab(int cat) {  // TODO: grab from slots
		return 0 +
		goto_radar_item_position(new RadarArgs(cat), true, false, false) +
		//goto_radar_position(new RadarArgs(cat)) +
		grab_from_ground(cat);
	}
	
	int goto_o(point pos, float dist=1.5) {
		return goto_pp(pos, inverse_direction(pos), dist);
	}
	
	int goto_p(point pos, float dist=1.5) {
		return goto_pp(pos, pos.z, dist);
	}
	
	int goto_pp(point pos, float direct, float dist=1.5) {
		float dist_to_pos;
		
		pos.x -= cos(direct) * dist;
		pos.y -= sin(direct) * dist;
		goto(pos);
		dist_to_pos = distance2d(actor.position, pos);
		
		if (dist_to_pos > 0.1 and dist_to_pos < 10.0) {
			goto_straight(pos, 0);  // to more precise position
		}
		
		orient(direct);
		return round(distance2d(actor.position, pos));
	}
	
	int goto_radar_item_position(RadarArgs a, bool grab_ground=true, bool grab_slots=true, bool grab_load=false) {
		object item;
		
		item = radar_item(a, grab_ground, grab_slots, grab_load);
		
		if (item == null) {
			return 1;
		}
		
		return goto(item.position);
	}
	
	int goto_radar_position(RadarArgs a) {
		object item;
		
		item = radar_(a);
		
		if (item == null) {
			return 1;
		}
		
		return goto(item.position);
	}
	
	void goto_straight(point pos, float dist=1.5) {
		turn(direction(pos));
		move(distance2d(pos, actor.position) - dist);
	}
	
	void _drop_out() {
		point pos;
		
		pos = actor.position;
		pos.z = actor.orientation;
		goto(space(actor.position, 3));
		drop();
		goto_p(pos);
	}
	
	int grab_from_ground(int cat, int oper=InFront, float min_energy=0, float max_energy=1) {
		float max_wait; RadarArgs radar_args;
		
		for (int retries = 3; retries >= 0; --retries) {
			if (actor.load == null) {
				break;
			}
			
			if (actor.load.category == cat and actor.load.energyLevel >= min_energy
			                               and actor.load.energyLevel <= max_energy) {
				log("warning grab_from_ground needed item is already loaded before grab");
				return 0;
			}
			
			log("warning grab_from_ground another item is already loaded before grab");
			_drop_out();
		}
		
		radar_args = new RadarArgs(cat, 0, 30, 0, 6);
		
		if (oper == Behind) {
			radar_args.angle = 180;
		}
		
		for (int retries = 3; retries >= 0; --retries) {
			if (radar_wait(radar_args) == null) {
				log("warning grab_from_ground can not find expected object in front -- timeout expired");
				return 1;
			}
			
			grab(oper);
			
			if (actor.load == null) {
				wait(0.5);
				continue;
			} else {
				if (actor.load.category == cat and actor.load.energyLevel >= min_energy and actor.load.energyLevel <= max_energy) {
					return 0;
				}
			}
			
			log("warning grab_from_ground another item is loaded after grab");
			_drop_out();
		}
		
		return 1;
	}
	
	point grab_position(float dist=1.5) {
		point pos;
		
		pos.x = actor.position.x + cos(actor.orientation) * dist;
		pos.y = actor.position.y + sin(actor.orientation) * dist;
		return pos;
	}
	
	bool has_slot(int cat) {
		return is_bot(cat)
		or cat == DefenseTower
		or cat == NuclearPlant
		or cat == PowerPlant
		or cat == ResearchCenter;
	}
	
	float inverse_direction(point pos) {
		// TODO: it is possible to do it without if statement
		
		if (actor.position.y > pos.y) {
			return 270 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
		}
		
		return 90 - atan((pos.x - actor.position.x) / (pos.y - actor.position.y));
	}
	
	bool is_blocked(object item) {
		return false;  // TODO
	}
	
	bool is_bot(int cat) {
		return true;  // TODO
	}
	
	bool is_item(int cat) {
		return false
		or cat == TitaniumOre
		or cat == Titanium
		or cat == PowerCell;  // TODO
	}
	
	bool is_structure(int cat) {
		return false
		or cat == BotFactory
		or cat == Converter
		or cat == DefenseTower
		or cat == ResearchCenter
		or cat == PowerPlant
		or cat == PowerStation;  // TODO
	}
	
	void log(string text) {
		file handler = new file();
		handler.open(logfile, "a");
		handler.writeln(round_digits(abstime(), 1) + " " + actor.id + " " + text);
		handler.close();
	}
	
	float normalize_angle(float angle) {
		return angle - 360 * round(angle / 360);
	}
	
	void orient(float direct) {
		turn(normalize_angle(direct - actor.orientation));
	}
	
	// TODO: use RadarArgs
	object radar_best_cell(int angle=0, int focus=360, int min=0, int max=1024) {
		object[] nuclear_cells; int nuclear_max_index; float nuclear_max_value;
		object[] power_cells; int power_max_index; float power_max_value;
		
		nuclear_cells = radarall(NuclearCell, angle, focus, min, max);
		nuclear_max_index = -1;
		nuclear_max_value = 0;
		
		for (int i = 0; i < sizeof(nuclear_cells); ++i) {
			if (nuclear_cells[i].energyLevel >= nuclear_max_value) {
				nuclear_max_index = i;
				nuclear_max_value = nuclear_cells[i].energyLevel;
			}
		}
		
		power_cells = radarall(PowerCell, angle, focus, min, max);
		power_max_index = -1;
		power_max_value = 0;
		
		for (int i = 0; i < sizeof(power_cells); ++i) {
			if (power_cells[i].energyLevel >= power_max_value) {
				power_max_index = i;
				power_max_value = power_cells[i].energyLevel;
			}
		}
		
		if (power_max_value >= 10 * nuclear_max_value) {
			if (power_max_value == 0) {
				return null;
			}
			
			return power_cells[power_max_index];
		}
		
		if (nuclear_max_value == 0) {
			return null;
		}
		
		return nuclear_cells[nuclear_max_index];
	}
	
	object radar_item(RadarArgs a, bool radar_ground=true, bool radar_slots=true, bool radar_load=false) {
		object[] items; object item; int[] item_cats;
		
		item_cats = a.cat;
		items = radarall(Any, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
		
		for (int i = 0; i < sizeof(items); ++i) {
			item = items[i];
			
			if (radar_ground and contains(item_cats, item.category)) {
				return item;
			}
			
			if (radar_slots and has_slot(item.category) and item.energyCell != null
			                and contains(item_cats, item.energyCell.category)) {
				return item.energyCell;
			}
			
			if (radar_load and can_load(item.category) and item.load != null
			               and contains(item_cats, item.load.category)) {
				return item.load;
			}
		}
		
		return null;
	}
	
	object radar_wait(RadarArgs a, float wait_time=nan) {
		object item;
		
		if (wait_time == nan) {
			wait_time = wait_for_cat(a.cat[0]);
		}
		
		for (;;) {
			item = radar_(a);
			
			if (item != null) {
				break;
			}
			
			if (wait_time <= 0) {
				return null;
			}
			
			wait_time -= 0.1;
			wait(0.1);
		}
		
		return item;
	}
	
	object radar_(RadarArgs a) {
		return radar(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	object[] radarall_(RadarArgs a) {
		return radarall(a.cat, a.angle, a.focus, a.min, a.max, a.sens, a.filter);
	}
	
	void switch_cell() {
		grab(InFront);    drop(Behind);
		grab(EnergyCell); drop(InFront);
		grab(Behind);     drop(EnergyCell);
	}
	
	void switch_cell_quick() {
		if (actor.load != null) {
			drop();
		}
		
		grab(EnergyCell); drop(Behind);
		grab(InFront);    drop(EnergyCell);
	}
	
	void switch_for(object item) {
		assert(actor.load != null).id;
		assert(item.energyCell != null).id;
		
		turn(direction(item.position));
		drop(Behind);
		grab();
		turn(-90);
		drop();
		turn(90);
		grab(Behind);
		drop();
	}
	
	float random(float min, float max) {
		return rand() * (max - min) + min;
	}
	
	float round_digits(float value, int digits) {
		int a = pow(10, digits);
		return round(value * a) / a;
	}
	
	int to_int(bool flag) {
		if (flag) {
			return 1;
		}
		
		return 0;
	}
	
	int[] to_list(int cat) {
		int[] cat_list;
		
		cat_list[0] = cat;
		return cat_list;
	}
	
	bool _helix_helper(point pos) {
		object item;
		
		item = search(Any, pos, 0, 1.7);
		
		if (item != null) {
			return false;
		}
		
		goto_p(pos);
		drop();
		return true;
	}
	
	point team_transform(point p) {
		if (actor.team == 2) {
			p.x *= -1;
			p.y *= -1;
			p.z = 180 + p.z;
		}
		
		return p;
	}
	
	float wait_for_cat(int cat) {
		if (cat == Titanium   ) { return 15.5; }
		if (cat == TitaniumOre) { return 10.5; }
		if (cat == PowerCell  ) { return 12.5; }
		if (cat == UraniumOre ) { return 30.5; }
		return 15.5;  // Build time
	} 
}

public class Message {
	static int max_message_capacity = 80;
	static int max_messages_count = 4;
	static string input_separator = " ";
	static string output_separator = " ";
	
	private string buffer = "";
	
	void add(string text) {
		buffer += text;
	}
	
	void show() {
		string message_buffer; int space_index;
		
		if (strlen(buffer) > max_messages_count * max_message_capacity) {
			message("Message too long " + strlen(buffer), DisplayError);
			return;
		}
		
		for (int i = max_messages_count - 1; i >= 0; --i) {
			message_buffer = "";
			
			for (int j = 0; j < 10; ++j) {
				space_index = strfind(buffer, input_separator);
				
				if (space_index == nan) {
					// last word in buffer
					message_buffer += buffer;
					buffer = "";
					break;
				}
				
				if (strlen(message_buffer) + space_index > max_message_capacity) {
					break;
				}
				
				if (strlen(message_buffer) > 0) {
					message_buffer += output_separator;
				}
				
				message_buffer += strleft(buffer, space_index);
				buffer = strright(buffer, strlen(buffer) - space_index - 1);
			}
			
			message(message_buffer);
			
			if (strlen(buffer) == 0) {
				return;
			}
		}
		
		message("Fail to split message. Too long " + strlen(buffer), DisplayError);
	}
}

extern void object::EBoostLib() {
	EBoost e(this);
	//// Unit Tests
	//message(e.normalize_angle(360 * 4 + 30) + " = " + 30);
	//message(e.normalize_angle(179) + " = " + 179);
	//message(e.normalize_angle(180) + " = " + 180 + " or " + -180);
	//message(e.normalize_angle(181) + " = " + -179);
	//message(e.normalize_angle(-179) + " = " + -179);
	//message(e.normalize_angle(-180) + " = " + -180 + " or " + 180);
	//message(e.normalize_angle(-181) + " = " + 179);
	//message(e.normalize_angle(360 * -11 + 30) + " = " + 30);
	//e.orient(this, -360);
	//message(orientation);
}
