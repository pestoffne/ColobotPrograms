// Depends:
// lib_pathpart.cbot
#include <macro.cbot>

#define ARC_LENGTH(angle, radius) (PI * abs(angle) * (radius) / 180)
#define RADIUS_TO_MOTOR_VALUE(radius) (1 - 2 / ((radius) + 1))
#define PREDICT_VELOCITY(motor_left, motor_right) (((motor_left) + (motor_right)) * 2.5)

NAMED_TUPLE_EXTENDED(PathArc, PathPart, 5,
        float, center_x,,
        float, center_y,,
        float, radius,,     // assume radius >= 0
        float, from_angle,, // assume -180 < angle <= 180
        float, to_angle,)

public point PathArc::from() {
	return new point(center_x + radius * cos(from_angle), center_y + radius * sin(from_angle));
}

public point PathArc::to() {
	return new point(center_x + radius * cos(to_angle), center_y + radius * sin(to_angle));
}

public float PathArc::length() {
	return ARC_LENGTH(to_angle - from_angle, radius);
}

public float PathArc::time() {
	return ARC_LENGTH(to_angle - from_angle, radius)
	* PREDICT_VELOCITY(RADIUS_TO_MOTOR_VALUE(radius), 1);
}

public void PathArc::go(EBoost e) {
	nan * 0;  // Not implemented
}

#if 0
public PathArc create_arc(point from, point to, point center, float radius) {
	return new PathArc(center.x, center.y, radius,
	    GET_ANGLE(from.x - center.x, from.y - center.y),
	    GET_ANGLE(to.x - center.x, to.y - center.y));
}
#endif

public PathArc create_arc(
float from_x, float from_y, float to_x, float to_y, float center_x, float center_y, float radius) {
	return new PathArc(center_x, center_y, radius,
	    GET_ANGLE(from_x - center_x, from_y - center_y),
	    GET_ANGLE(to_x - center_x, to_y - center_y));
}
