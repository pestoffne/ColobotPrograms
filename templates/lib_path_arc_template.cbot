// Depends:
// lib_pathpart.cbot
#include <macro.cbot>

#define ARC_LENGTH(angle, radius) (PI * abs(angle) * (radius) / 180)
#define FROM_ANGLE(arc) GET_ANGLE(arc.from_x - arc.center_x, arc.from_y - arc.center_y)
#define TO_ANGLE(arc) GET_ANGLE(arc.to_x - arc.center_x, arc.to_y - arc.center_y)

public class PathArc extends PathPart {
	public float from_x, from_y, to_x, to_y, center_x, center_y, radius, from_angle, to_angle, max_progress;
	public PolarCoordinateSystem cs;
}

public void PathArc::PathArc(float from_x, float from_y, float to_x, float to_y,
float center_x, float center_y, float radius) {
	this.from_x = from_x;
	this.from_y = from_y;
	this.to_x = to_x;
	this.to_y = to_y;
	this.center_x = center_x;
	this.center_y = center_y;
	this.radius = abs(radius);
	this.from_angle = FROM_ANGLE(this);
	this.to_angle = TO_ANGLE(this);
	this.max_progress = ARC_LENGTH(to_angle - from_angle, radius);
	this.cs = new PolarCoordinateSystem(
		center_x, center_y, from_angle, SIGN(to_angle - from_angle));
}

public point PathArc::from() {
	return new point(this.from_x, this.from_y);
}

public point PathArc::to() {
	return new point(this.to_x, this.to_y);
}

public float PathArc::length() {
	return ARC_LENGTH(this.to_angle - this.from_angle, this.radius);
}

public float PathArc::time() {
	return ARC_LENGTH(this.to_angle - this.from_angle, this.radius)
	/ PREDICT_VELOCITY(RADIUS_TO_MOTOR_VALUE(this.radius), 1);
}

public float PathArc::get_progress(float px, float py) {
	return ARC_LENGTH(this.cs.s(px, py).angle, this.radius);
}

public float PathArc::get_progress(point pos) {
	return ARC_LENGTH(this.cs.s(pos).angle, this.radius);
}

public float PathArc::max_progress() {
	return this.max_progress;
}

public point PathArc::get_position(float progress) {
	return this.cs.i(progress, this.radius);
}

public void PathArc::go(EBoost e) {
	nan * 0;  // Not implemented
}

public string PathArc::to_str() {
#if 1
	return "PathArc(center_x=" + ROUND_2(center_x) + ", center_y=" + ROUND_2(center_y)
	+ ", radius=" + ROUND_2(radius)
	+ ", from_angle=" + ROUND_2(from_angle) + ", to_angle=" + ROUND_2(to_angle)
	+ ", from_x=" + ROUND_2(from_x) + ", from_y=" + ROUND_2(from_y)
        + ", to_x=" + ROUND_2(to_x) + ", to_y=" + ROUND_2(to_y)
	+ ", length=" + ROUND_2(length()) + ", time=" + ROUND_2(time()) + ")";
#else
	return "cv2.line(img,(" + round(from_x * 10) + "," + round(1000 - from_y * 10)
	+ "),(" + round(to_x * 10) + "," + round(1000 - to_y * 10) + "), 1)"
	+ "\ncv2.circle(img,(" + round(center_x * 10) + "," + round(1000 - center_y * 10) + "),"
	+ round(radius * 10) + ", 1)";
#endif
}
