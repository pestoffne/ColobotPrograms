#include <macro.cbot>

#if SIZE - 2
#	define IF_3D(...) __VA_ARGS__
#	define SIZE_P1 4
#else
#	define IF_3D(...)
#	define SIZE_P1 3
#endif

public class CAT(AffineCoordinateSystem, SIZE, D) {
	private Matrix_float _m;
	
	public void CAT(AffineCoordinateSystem, SIZE, D)(Matrix_float m) {
		this._m = m;
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) translate(float dx, float dy) {
		return this;  // Not implemented
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) scale(float dx, float dy) {
		return this;  // Not implemented
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) rotate(float angle) {
		return this;  // Not implemented
	}
	
	public point _(point pos) {
		return CAT(_m2p_, SIZE, d)(this._m.mul(CAT(_p2m_, SIZE, d)(pos)).begin());
	}
}

/*private*/ Matrix_float CAT(_p2m_, SIZE, d)(point pos) {
	return new Matrix_float(1, SIZE_P1, matrix_values(pos.x, pos.y, IF_3D(pos.z,) 1));
}

/*private*/ point CAT(_m2p_, SIZE, d)(MatrixIterator_float iter) {
	return new point(iter.value(), iter.shift().value() IF_3D(, iter.shift().value()));
}

public CAT(AffineCoordinateSystem, SIZE, D) CAT(coordinate_system_from_matrix_, SIZE, d)(Matrix_float ab) {
	nan * 0;  // Not implemented
	return null;
}

public CAT(AffineCoordinateSystem, SIZE, D) CAT(coordinate_system_identity_, SIZE, d)() {
	return new CAT(AffineCoordinateSystem, SIZE, D)(matrix_eye_float(SIZE_P1));
}

extern void CAT(Library_AffineCoordinateSystem, SIZE, D)() {
}

