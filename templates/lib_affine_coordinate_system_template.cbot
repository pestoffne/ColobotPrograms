#include <macro.cbot>

#if SIZE - 2
#	define IF_2D(...)
#	define IF_3D(...) __VA_ARGS__
#	define SIZE_P1 4
#else
#	define IF_2D(...) __VA_ARGS__
#	define IF_3D(...)
#	define SIZE_P1 3
#endif

public class CAT(AffineCoordinateSystem, SIZE, D) {
	private Matrix_float _m;
	
	public void CAT(AffineCoordinateSystem, SIZE, D)(Matrix_float m) {
		this._m = m;
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) translate(float dx, float dy IF_3D(, float dz)) {
		return new CAT(AffineCoordinateSystem, SIZE, D)(this._m.mul(
		new Matrix_float(SIZE_P1, SIZE_P1, matrix_values(
			IF_2D( 1,  0, dx,)
			IF_2D( 0,  1, dy,)
			IF_2D( 0,  0,  1 )
			
			IF_3D( 1,  0,  0, dx,)
			IF_3D( 0,  1,  0, dy,)
			IF_3D( 0,  0,  1, dz,)
			IF_3D( 0,  0,  0,  1 )
		))));
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) scale(float dx, float dy IF_3D(, float dz)) {
		return new CAT(AffineCoordinateSystem, SIZE, D)(this._m.mul(
		new Matrix_float(SIZE_P1, SIZE_P1, matrix_values(
			IF_2D(dx,  0,  0,)
			IF_2D( 0, dy,  0,)
			IF_2D( 0,  0,  1 )
			
			IF_3D(dx,  0,  0,  0,)
			IF_3D( 0, dy,  0,  0,)
			IF_3D( 0,  0, dz,  0,)
			IF_3D( 0,  0,  0,  1 )
		))));
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) rotate(float angle) {
		return new CAT(AffineCoordinateSystem, SIZE, D)(this._m.mul(
		new Matrix_float(SIZE_P1, SIZE_P1, matrix_values(
			IF_2D(cos(angle), -sin(angle), 0,)
			IF_2D(sin(angle),  cos(angle), 0,)
			IF_2D(         0,           0, 1 )
			
			IF_3D(cos(angle), -sin(angle), 0, 0,)
			IF_3D(sin(angle),  cos(angle), 0, 0,)
			IF_3D(         0,           0, 1, 0,)
			IF_3D(         0,           0, 0, 1 )
		))));
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) invert_y() {
		return new CAT(AffineCoordinateSystem, SIZE, D)(this._m.mul(
		new Matrix_float(SIZE_P1, SIZE_P1, matrix_values(
			IF_2D( 1,  0, 0,)
			IF_2D( 0, -1, 0,)
			IF_2D( 0,  0, 1 )
			
			IF_3D( 1,  0, 0, 0,)
			IF_3D( 0, -1, 0, 0,)
			IF_3D( 0,  0, 1, 0,)
			IF_3D( 0,  0, 0, 1 )
		))));
	}
	
	public CAT(AffineCoordinateSystem, SIZE, D) inverse() {
		return new CAT(AffineCoordinateSystem, SIZE, D)(this._m.inverse());
	}
	
	public string to_str() {
		return this._m.to_str();
	}
	
	public point _(float x, float y IF_3D(, float z)) {
		return CAT(_m2p_, SIZE, d)(this._m.mul(
		new Matrix_float(1, SIZE_P1, matrix_values(x, y, IF_3D(z,) 1))).begin());
	}
	
	public point _(point pos) {
		return CAT(_m2p_, SIZE, d)(this._m.mul(CAT(_p2m_, SIZE, d)(pos)).begin());
	}
}

/*private*/ Matrix_float CAT(_p2m_, SIZE, d)(point pos) {
	return new Matrix_float(1, SIZE_P1, matrix_values(pos.x, pos.y, IF_3D(pos.z,) 1));
}

/*private*/ point CAT(_m2p_, SIZE, d)(MatrixIterator_float iter) {
	return new point(iter.value(), iter.shift().value() IF_3D(, iter.shift().value()));
}

public CAT(AffineCoordinateSystem, SIZE, D) CAT(coordinate_system_from_matrix_, SIZE, d)(Matrix_float ab) {
	ab.vstack_mut(new Matrix_float(SIZE_P1, 1, matrix_values(
		IF_2D( 0,  0,  1 )
		IF_3D( 0,  0,  0,  1 )
	)));
	
	return new CAT(AffineCoordinateSystem, SIZE, D)(ab);
}

public CAT(AffineCoordinateSystem, SIZE, D) CAT(coordinate_system_identity_, SIZE, d)() {
	return new CAT(AffineCoordinateSystem, SIZE, D)(matrix_eye_float(SIZE_P1));
}

extern void CAT(Library_AffineCoordinateSystem, SIZE, D)() {
}

