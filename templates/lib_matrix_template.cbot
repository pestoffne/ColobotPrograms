#include <macro.cbot>

NAMED_TUPLE(CAT(MatrixElem_, TYPE), 3,
	TYPE, value, = NULL,
	CAT(MatrixElem_, TYPE), right, = null,
	CAT(MatrixElem_, TYPE), down, = null)

#define MATRIX_VALUES_ARGUMENT(number, ...) , TYPE v##number
#define MATRIX_VALUES_ASSIGN(number, ...) p1 = p1.right = new CAT(MatrixElem_, TYPE)(v##number);
#define MATRIX_VALUES(count) \
	public CAT(MatrixElem_, TYPE) matrix_values(TYPE v0 REPEAT(count, MATRIX_VALUES_ARGUMENT)) { \
		CAT(MatrixElem_, TYPE) p0, p1; \
		p0 = p1 = new CAT(MatrixElem_, TYPE)(v0); \
		REPEAT(count, MATRIX_VALUES_ASSIGN) \
		return p1.right = p0; \
	}

MATRIX_VALUES(5)
MATRIX_VALUES(8)

public class CAT(Matrix_, TYPE) {
	private CAT(MatrixElem_, TYPE) _root;
	private int _width;
	private int _height;
	
	private void _set_shape() {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		p1 = p2 = this._root;
		
		repeat(this._width) {
			p1 = p1.right;
		}
		
		repeat(this._width * (this._height - 1)) {
			p2.down = p1;
			p1 = p1.right;
			p2 = p2.right;
		}
		
		p1 = p1.right;
		
		repeat(this._width - 1) {
			p2.down = p1;
			p1 = p1.right;
			p2 = p2.right;
		}
		
		p2.down = this._root;
	}
	
	public void CAT(Matrix_, TYPE)(int width, int height, CAT(MatrixElem_, TYPE) values) {
		this._width = width;
		this._height = height;
		this._root = values;
		this._set_shape();
	}
	
	public bool eq(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		if (this._width != that._width or this._height != that._height) {
			return false;
		}
		
		p1 = this._root;
		p2 = that._root;
		
		repeat(this._width * this._height) {
			if (p1.value != p2.value) {
				return false;
			}
			
			p1 = p1.right;
			p2 = p2.right;
		}
		
		return true;
	}
	
	public bool ne(CAT(Matrix_, TYPE) that) {
		return not this.eq(that);
	}
	
	public CAT(Matrix_, TYPE) mul(CAT(Matrix_, TYPE) that) {
		// TODO
		return that;
	}
}

extern void CAT(Library_Matrix_, TYPE)() {
}
