#include <macro.cbot>

NAMED_TUPLE(CAT(MatrixElem_, TYPE), 3,
	TYPE, value, = ZERO,
	CAT(MatrixElem_, TYPE), right, = null,
	CAT(MatrixElem_, TYPE), down, = null)

#define MATRIX_VALUES_ARGUMENT(number, ...) , TYPE v##number
#define MATRIX_VALUES_ASSIGN(number, ...) p1 = p1.right = new CAT(MatrixElem_, TYPE)(v##number);
#define MATRIX_VALUES(count) \
	public CAT(MatrixElem_, TYPE) matrix_values(TYPE v0 REPEAT(count, MATRIX_VALUES_ARGUMENT)) { \
		CAT(MatrixElem_, TYPE) p0, p1; \
		p0 = p1 = new CAT(MatrixElem_, TYPE)(v0); \
		REPEAT(count, MATRIX_VALUES_ASSIGN) \
		return p0; \
	}

MATRIX_VALUES(1)
MATRIX_VALUES(2)
MATRIX_VALUES(3)
MATRIX_VALUES(5)
MATRIX_VALUES(8)
MATRIX_VALUES(15)

public class CAT(MatrixIterator_, TYPE) {
	protected CAT(MatrixElem_, TYPE) _elem;
	
	public void CAT(MatrixIterator_, TYPE)(CAT(MatrixElem_, TYPE) elem) {
		this._elem = elem;
	}
	
	public CAT(MatrixIterator_, TYPE) copy() {
		return new CAT(MatrixIterator_, TYPE)(this._elem);
	}
	
	public bool equal(CAT(MatrixIterator_, TYPE) that) {
		return this._elem == that._elem;
	}
	
	public bool is_null() {
		return this._elem == null;
	}
	
	public TYPE value() {
		return this._elem.value;
	}
	
	public CAT(MatrixIterator_, TYPE) shift() {
		this._elem = this._elem.right;
		return this;
	}
}

public class CAT(MatrixIteratorVertical_, TYPE) extends CAT(MatrixIterator_, TYPE) {
	public void CAT(MatrixIteratorVertical_, TYPE)(CAT(MatrixElem_, TYPE) elem) {
		this._elem = elem;
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) copy() {
		return new CAT(MatrixIteratorVertical_, TYPE)(this._elem);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) shift() {
		this._elem = this._elem.down;
		return this;
	}
}

public class CAT(Matrix_, TYPE) {
	private CAT(MatrixElem_, TYPE) _root;
	private int _width;
	private int _height;
	
	public /* only for tests */ CAT(MatrixElem_, TYPE) _root() {
		return this._root;
	}
	
	private void _set_shape_mut() {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		p1 = p2 = this._root;
		
		repeat (this._width) {
			p1 = p1.right;
		}
		
		repeat (this._width * (this._height - 1)) {
			p2.down = p1;
			p2 = p2.right;
			p1 = p1.right;
		}
		
		p1 = this._root.right;
		
		repeat (this._width - 1) {
			p2.down = p1;
			p2 = p2.right;
			p1 = p1.right;
		}
	}
	
	public void CAT(Matrix_, TYPE)(int width, int height, CAT(MatrixElem_, TYPE) values) {
		this._width = width;
		this._height = height;
		this._root = values;
		this._set_shape_mut();
	}
	
	public CAT(MatrixIterator_, TYPE) begin() {
		return new CAT(MatrixIterator_, TYPE)(this._root);
	}
	
	public CAT(MatrixIterator_, TYPE) end() {
		return new CAT(MatrixIterator_, TYPE)(null);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) vbegin() {
		return new CAT(MatrixIteratorVertical_, TYPE)(this._root);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) vend() {
		return new CAT(MatrixIteratorVertical_, TYPE)(null);
	}
	
	public int width() {
		return this._width;
	}
	
	public int height() {
		return this._height;
	}
	
	public int count() {
		return this._width * this._height;
	}
	
	public bool eq(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		if (this._width != that._width or this._height != that._height) {
			return false;
		}
		
		p1 = this._root;
		p2 = that._root;
		
		repeat(this._width * this._height) {
			if (p1.value != p2.value) {
				return false;
			}
			
			p1 = p1.right;
			p2 = p2.right;
		}
		
		return true;
	}
	
	public bool ne(CAT(Matrix_, TYPE) that) {
		return not this.eq(that);
	}
	
	public void debug_dump(string filename="matrix_debug_dump.txt") {
		CAT(MatrixElem_, TYPE) p; string line; file f;
		
		f = new file();
		f.open(filename, "w");
		
		line = "width=" + this._width + ",height=" + this._height;
		p = this._root;
		if (p == null) {
			line += ",root=null";
		} else {
			line += ",root=" + p.value;
		}
		f.writeln(line);
		
		repeat (100) {
			if (p == null) {
				break;
			}
			
			line = "value=" + p.value;
			
			if (p.right == null) {
				line += ",right=null";
			} else {
				line += ",right=" + p.right.value;
			}
			
			if (p.down == null) {
				line += ",down=null";
			} else {
				line += ",down=" + p.down.value;
			}
			
			f.writeln(line);
			p = p.right;
		}
		
		f.close();
	}
	
	public string to_str() {
		string res; CAT(MatrixIterator_, TYPE) iter;
		
		iter = this.begin();
		res = "[";
		
		for (int i = this._height - 1;; --i) {
			res += "[";
			
			for (int j = this._width - 1;; --j) {
				res += iter.value();
				iter.shift();
				
				if (j <= 0) {
					break;
				}
				
				res += ",";
			}
			
			res += "]";
			
			if (i <= 0) {
				break;
			}
			
			res += ",";
		}
		
		res += "]";
		return res;
	}
	
	public point to_point() {
		CAT(MatrixElem_, TYPE) p;
		
		p = this._root;
		
		// assume matrix count is 2 or 3
		if (this.count() == 2) {
			return new point(p.value, p.right.value);
		}
		
		return new point(p.value, p.right.value, p.right.right.value);
	}
	
	private CAT(MatrixElem_, TYPE) _copy_values() {
		CAT(MatrixElem_, TYPE) p1, p2, root;
		
		// assume there is at least one element in matrix
		root = p2 = new CAT(MatrixElem_, TYPE)(this._root.value);
		
		for (p1 = this._root.right; p1 != null; p1 = p1.right) {
			p2 = p2.right = new CAT(MatrixElem_, TYPE)(p1.value);
		}
		
		return root;
	}
	
	private CAT(MatrixElem_, TYPE) _copy_transposed() {
		CAT(MatrixElem_, TYPE) p1, p2, root;
		
		// assume there is at least one element in matrix
		root = p2 = new CAT(MatrixElem_, TYPE)(this._root.value);
		
		for (p1 = this._root.down; p1 != null; p1 = p1.down) {
			p2 = p2.right = new CAT(MatrixElem_, TYPE)(p1.value);
		}
		
		return root;
	}
	
	public CAT(Matrix_, TYPE) copy() {
		return new CAT(Matrix_, TYPE)(this._width, this._height, this._copy_values());
	}
	
	private CAT(MatrixElem_, TYPE) _at_y(int y) {
		CAT(MatrixElem_, TYPE) p;
		
		p = this._root;
		
                repeat (y) {
                        p = p.down;
                }
		
                return p;
	}
	
	private void _add_row_mut(CAT(MatrixElem_, TYPE) p_from, CAT(MatrixElem_, TYPE) p_to,
	TYPE coef, int width_m1) {
		p_to.value += p_from.value * coef;
		
		repeat (width_m1) {
			p_to = p_to.right;
			p_from = p_from.right;
			p_to.value += p_from.value * coef;
		}
	}
	
	private void _mul_row_mut(CAT(MatrixElem_, TYPE) p, TYPE coef, int width_m1) {
		p.value *= coef;
		
		repeat (width_m1) {
			p = p.right;
			p.value *= coef;
		}
	}
	
	private void _triangulate_mut() {
		CAT(MatrixElem_, TYPE) p_diag, p_i; int x, size;
		
		// assume width == height
		size = this._width;
		p_diag = this._root;
		x = size - 1;
		
		p_i = p_diag;
		
		repeat (x) {
			p_i = p_i.down;
			this._add_row_mut(p_diag, p_i, -p_i.value / p_diag.value, x);
		}
		
		repeat (x) {
			--x;
			p_diag = p_diag.right.down;
			
			p_i = p_diag;
			
			repeat (x) {
				p_i = p_i.down;
				this._add_row_mut(p_diag, p_i, -p_i.value / p_diag.value, x);
			}
		}
	}
	
	public TYPE determenant() {
		CAT(Matrix_, TYPE) m; CAT(MatrixElem_, TYPE) p; TYPE acc;
		
		m = this.copy();
		m._triangulate_mut();
		
		// assume width == height
		// assume there is at least one element
		p = m._root;
		acc = p.value;
		
		repeat (this._width - 1) {
			p = p.right.down;
			acc *= p.value;
		}
		
		return acc;
	}
	
	public CAT(Matrix_, TYPE) inverse() {
		CAT(Matrix_, TYPE) m1, m2; TYPE coef; int x, y, size;
		CAT(MatrixElem_, TYPE) p1_diag, p1_diag_left, p1_diag_top, p1_i, p1_i_left, p2_diag_left, p2_i_left;
		
		// assume width == height
		size = this._width;
		
		m1 = this.copy();
		m2 = CAT(matrix_eye_, TYPE)(size);
		
		x = 0;
		p1_i = p1_i_left = p1_diag = p1_diag_left = p1_diag_top = m1._root;
		p2_diag_left = p2_i_left = m2._root;
		
		LOOP {
			y = 0;
			p1_i_left = m1._root;
			p2_i_left = m2._root;
			
			coef = 1 / p1_diag.value;
			m1._mul_row_mut(p1_diag_left, coef, size - 1);
			m2._mul_row_mut(p2_diag_left, coef, size - 1);
			
			LOOP {
				if (x != y) {
					coef = -p1_i.value;
					m1._add_row_mut(p1_diag_left, p1_i_left, coef, size - 1);
					m2._add_row_mut(p2_diag_left, p2_i_left, coef, size - 1);
				}
				
				p1_i = p1_i.down;
				
				if (++y >= size) {
					break;
				}
				
				p1_i_left = p1_i_left.down;
				p2_i_left = p2_i_left.down;
			}
			
			if (++x >= size) {
				break;
			}
			
			p1_diag = p1_diag.right.down;
			p1_diag_top = p1_diag_top.right;
			p1_diag_left = p1_diag_left.down;
			p2_diag_left = p2_diag_left.down;
		}
		
		return m2;
	}
	
	public CAT(Matrix_, TYPE) transpose() {
		return new CAT(Matrix_, TYPE)(this._height, this._width, this._copy_transposed());
	}
	
	public void transpose_mut() {
		CAT(MatrixElem_, TYPE) p, tmp_p; int tmp_i;
		
		for (p = this._root; p != null; p = p.right) {
			tmp_p = p.right;
			p.right = p.down;
			p.down = tmp_p;
		}
		
		tmp_i = this._width;
		this._width = this._height;
		this._height = tmp_i;
	}
	
	public CAT(Matrix_, TYPE) add(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p_this, p_that, p_out, p_root;
		
		p_this = this._root;
		p_that = that._root;
		p_root = p_out = new CAT(MatrixElem_, TYPE)(p_this.value + p_that.value);
		
		repeat (this._width * this._height - 1) {
			p_this = p_this.right;
			p_that = p_that.right;
			p_out = p_out.right = new CAT(MatrixElem_, TYPE)(p_this.value + p_that.value);
		}
		
		return new CAT(Matrix_, TYPE)(this._width, this._height, p_root);
	}
	
	public void add_mut(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		p1 = this._root;
		p2 = that._root;
		
		repeat (this._width * this._height) {
			p1.value += p2.value;
			p1 = p1.right;
			p2 = p2.right;
		}
	}
	
	private CAT(MatrixElem_, TYPE) _mul_helper(CAT(MatrixElem_, TYPE) p_this, CAT(MatrixElem_, TYPE) p_that) {
		CAT(MatrixElem_, TYPE) acc;
		
		acc = new CAT(MatrixElem_, TYPE)();
		repeat(this._width) {
			acc.value += p_this.value * p_that.value;
			p_this = p_this.right;
			p_that = p_that.down;
		}
		
		return acc;
	}
	
	public CAT(Matrix_, TYPE) mul(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p_this, p_that, p_out, p_dummy;
		
		if (this._width != that._height) {
			return null;
		}
		
		p_this = this._root;
		p_that = that._root;
		p_dummy = p_out = new CAT(MatrixElem_, TYPE)();
		
		repeat(this._height) {
			repeat(that._width) {
				p_out = p_out.right = this._mul_helper(p_this, p_that);
				p_that = p_that.right;
			}
			p_this = p_this.down;
			p_that = that._root;
		}
		
		return new CAT(Matrix_, TYPE)(that._width, this._height, p_dummy.right);
	}
}

public CAT(Matrix_, TYPE) CAT(matrix_eye_, TYPE)(int size) {
	CAT(MatrixElem_, TYPE) p0, p1;
	
	p0 = p1 = new CAT(MatrixElem_, TYPE)(ONE);
	
	repeat (size - 1) {
		repeat (size) {
			p1 = p1.right = new CAT(MatrixElem_, TYPE)(ZERO);
		}
		
		p1 = p1.right = new CAT(MatrixElem_, TYPE)(ONE);
	}
	
	return new CAT(Matrix_, TYPE)(size, size, p0);
}

public CAT(Matrix_, TYPE) CAT(matrix_zeros_, TYPE)(int width, int height) {
	CAT(MatrixElem_, TYPE) p0, p1;
	
	p0 = p1 = new CAT(MatrixElem_, TYPE)(ZERO);
	
	repeat (width * height - 1) {
		p1 = p1.right = new CAT(MatrixElem_, TYPE)(ZERO);
	}
	
	return new CAT(Matrix_, TYPE)(width, height, p0);
}

public CAT(Matrix_, TYPE) CAT(matrix_full_, TYPE)(int width, int height, TYPE value) {
	CAT(MatrixElem_, TYPE) p0, p1;
	
	p0 = p1 = new CAT(MatrixElem_, TYPE)(value);
	
	repeat (width * height - 1) {
		p1 = p1.right = new CAT(MatrixElem_, TYPE)(value);
	}
	
	return new CAT(Matrix_, TYPE)(width, height, p0);
}

public CAT(Matrix_, TYPE) CAT(to_2d_row_matrix_, TYPE)(point pos) {
	return new CAT(Matrix_, TYPE)(2, 1, matrix_values(pos.x, pos.y));
}

public CAT(Matrix_, TYPE) CAT(to_3d_row_matrix_, TYPE)(point pos) {
	return new CAT(Matrix_, TYPE)(3, 1, matrix_values(pos.x, pos.y, pos.z));
}

extern void CAT(Library_Matrix_, TYPE)() {
}
