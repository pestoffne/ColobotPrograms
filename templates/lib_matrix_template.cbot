#include <macro.cbot>

NAMED_TUPLE(CAT(MatrixElem_, TYPE), 3,
	TYPE, value, = ZERO,
	CAT(MatrixElem_, TYPE), right, = null,
	CAT(MatrixElem_, TYPE), down, = null)

#define MATRIX_VALUES_ARGUMENT(number, ...) , TYPE v##number
#define MATRIX_VALUES_ASSIGN(number, ...) p1 = p1.right = new CAT(MatrixElem_, TYPE)(v##number);
#define MATRIX_VALUES(count) \
	public CAT(MatrixElem_, TYPE) matrix_values(TYPE v0 REPEAT(count, MATRIX_VALUES_ARGUMENT)) { \
		CAT(MatrixElem_, TYPE) p0, p1; \
		p0 = p1 = new CAT(MatrixElem_, TYPE)(v0); \
		REPEAT(count, MATRIX_VALUES_ASSIGN) \
		return p0; \
	}

MATRIX_VALUES(3)
MATRIX_VALUES(5)
MATRIX_VALUES(8)

public class CAT(MatrixIterator_, TYPE) {
	protected CAT(MatrixElem_, TYPE) _elem;
	
	public void CAT(MatrixIterator_, TYPE)(CAT(MatrixElem_, TYPE) elem) {
		this._elem = elem;
	}
	
	public CAT(MatrixIterator_, TYPE) copy() {
		return new CAT(MatrixIterator_, TYPE)(this._elem);
	}
	
	public bool equal(CAT(MatrixIterator_, TYPE) that) {
		return this._elem == that._elem;
	}
	
	public bool is_null() {
		return this._elem == null;
	}
	
	public TYPE value() {
		return this._elem.value;
	}
	
	public CAT(MatrixIterator_, TYPE) shift() {
		this._elem = this._elem.right;
		return this;
	}
}

public class CAT(MatrixIteratorVertical_, TYPE) extends CAT(MatrixIterator_, TYPE) {
	public void CAT(MatrixIteratorVertical_, TYPE)(CAT(MatrixElem_, TYPE) elem) {
		this._elem = elem;
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) copy() {
		return new CAT(MatrixIteratorVertical_, TYPE)(this._elem);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) shift() {
		this._elem = this._elem.down;
		return this;
	}
}

public class CAT(Matrix_, TYPE) {
	private CAT(MatrixElem_, TYPE) _root;
	private int _width;
	private int _height;
	
	public /* only for tests */ CAT(MatrixElem_, TYPE) _root() {
		return this._root;
	}
	
	private void _set_shape_mut() {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		p1 = p2 = this._root;
		
		repeat(this._width) {
			p1 = p1.right;
		}
		
		for (;;) {
			p2.down = p1;
			
			if (p1.right == null) {
				break;
			}
			
			p1 = p1.right;
			p2 = p2.right;
		}
		
		p1 = this._root;
		
		repeat(this._width - 1) {
			p1 = p1.right;
			p2 = p2.right;
			p2.down = p1;
		}
	}
	
	public void CAT(Matrix_, TYPE)(int width, int height, CAT(MatrixElem_, TYPE) values) {
		this._width = width;
		this._height = height;
		this._root = values;
		this._set_shape_mut();
	}
	
	public CAT(MatrixIterator_, TYPE) begin() {
		return new CAT(MatrixIterator_, TYPE)(this._root);
	}
	
	public CAT(MatrixIterator_, TYPE) end() {
		return new CAT(MatrixIterator_, TYPE)(null);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) vbegin() {
		return new CAT(MatrixIteratorVertical_, TYPE)(this._root);
	}
	
	public CAT(MatrixIteratorVertical_, TYPE) vend() {
		return new CAT(MatrixIteratorVertical_, TYPE)(null);
	}
	
	public int width() {
		return this._width;
	}
	
	public int height() {
		return this._height;
	}
	
	public int count() {
		return this._width * this._height;
	}
	
	public bool eq(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		if (this._width != that._width or this._height != that._height) {
			return false;
		}
		
		p1 = this._root;
		p2 = that._root;
		
		repeat(this._width * this._height) {
			if (p1.value != p2.value) {
				return false;
			}
			
			p1 = p1.right;
			p2 = p2.right;
		}
		
		return true;
	}
	
	public bool ne(CAT(Matrix_, TYPE) that) {
		return not this.eq(that);
	}
	
	public string to_str() {
		string res; CAT(MatrixIterator_, TYPE) iter;
		
		iter = this.begin();
		res = "[";
		
		for (int i = this._height - 1;; --i) {
			res += "[";
			
			for (int j = this._width - 1;; --j) {
				res += iter.value();
				iter.shift();
				
				if (j <= 0) {
					break;
				}
				
				res += ",";
			}
			
			res += "]";
			
			if (i <= 0) {
				break;
			}
			
			res += ",";
		}
		
		res += "]";
		return res;
	}
	
	private CAT(MatrixElem_, TYPE) _copy_values() {
		CAT(MatrixElem_, TYPE) p1, p2, root;
		
		// assume there is at least one element in matrix
		root = p2 = new CAT(MatrixElem_, TYPE)(this._root.value);
		
		for (p1 = this._root.right; p1 != null; p1 = p1.right) {
			p2 = p2.right = new CAT(MatrixElem_, TYPE)(p1.value);
		}
		
		return root;
	}
	
	private CAT(MatrixElem_, TYPE) _copy_transposed() {
		CAT(MatrixElem_, TYPE) p1, p2, root;
		
		// assume there is at least one element in matrix
		root = p2 = new CAT(MatrixElem_, TYPE)(this._root.value);
		
		for (p1 = this._root.down; p1 != null; p1 = p1.down) {
			p2 = p2.right = new CAT(MatrixElem_, TYPE)(p1.value);
		}
		
		return root;
	}
	
	public CAT(Matrix_, TYPE) copy() {
		return new CAT(Matrix_, TYPE)(this._width, this._height, this._copy_values());
	}
	
	private CAT(MatrixElem_, TYPE) _at_y(int y) {
		CAT(MatrixElem_, TYPE) p;
		
		p = this._root;
		
                repeat (y) {
                        p = p.down;
                }
		
                return p;
	}
	
	private void _add_row_mut(CAT(MatrixElem_, TYPE) p_from, CAT(MatrixElem_, TYPE) p_to, TYPE coef) {
		for (;;) {
			p_to.value += p_from.value * coef;
			
			p_to = p_to.right;
			
			if (p_to == null) {
				break;
			}
			
			p_from = p_from.right;
		}
	}
	
	private void _triangulate_mut() {
		CAT(MatrixElem_, TYPE) p; int x, y;
		
		for (y = this._width - 2; y >= 0; --y) {
			p = this._at_y(y);
			x = this._width - y - 1;
			
			for (;;) {
				this._add_row_mut(p, p.down, -p.down.value / p.value);
				
				if (--x <= 0) {
					break;
				}
				
				p = p.right.down;
			}
		}
	}
	
	public TYPE determenant() {
		CAT(Matrix_, TYPE) m; CAT(MatrixElem_, TYPE) p; TYPE acc;
		
		m = this.copy();
		m._triangulate_mut();
		
		// assume width == height
		// assume there is at least one element
		acc = 1;
		p = m._root;
		
		for (;;) {
			acc *= p.value;
			
			if (p.right == null) {
				break;
			}
			
			p = p.right.down;
		}
		
		return acc;
	}
	
	public CAT(Matrix_, TYPE) inverse() {
		nan * 0;  // Not implemented
		return null;
	}
	
	public CAT(Matrix_, TYPE) transpose() {
		return new CAT(Matrix_, TYPE)(this._height, this._width, this._copy_transposed());
	}
	
	public void transpose_mut() {
		CAT(MatrixElem_, TYPE) p, tmp_p; int tmp_i;
		
		for (p = this._root; p != null; p = p.right) {
			tmp_p = p.right;
			p.right = p.down;
			p.down = tmp_p;
		}
		
		tmp_i = this._width;
		this._width = this._height;
		this._height = tmp_i;
	}
	
	public void add_mut(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p1, p2;
		
		p1 = this._root;
		p2 = that._root;
		
		repeat (this._width * this._height) {
			p1.value += p2.value;
			p1 = p1.right;
			p2 = p2.right;
		}
	}
	
	private CAT(MatrixElem_, TYPE) _mul_helper(CAT(MatrixElem_, TYPE) p_this, CAT(MatrixElem_, TYPE) p_that) {
		CAT(MatrixElem_, TYPE) acc;
		
		acc = new CAT(MatrixElem_, TYPE)();
		repeat(this._width) {
			acc.value += p_this.value * p_that.value;
			p_this = p_this.right;
			p_that = p_that.down;
		}
		
		return acc;
	}
	
	public CAT(Matrix_, TYPE) mul(CAT(Matrix_, TYPE) that) {
		CAT(MatrixElem_, TYPE) p_this, p_that, p_out, p_dummy; CAT(Matrix_, TYPE) res;
		
		if (this._width != that._height) {
			message("Can't multiply matrixes due it's sizes", DisplayError);
			return null;
		}
		
		p_this = this._root;
		p_that = that._root;
		p_dummy = p_out = new CAT(MatrixElem_, TYPE)();
		
		repeat(this._height) {
			repeat(that._width) {
				p_out = p_out.right = this._mul_helper(p_this, p_that);
				p_that = p_that.right;
			}
			p_this = p_this.down;
			p_that = that._root;
		}
		
		res = new CAT(Matrix_, TYPE)(this._height, that._width, p_dummy.right);
		return res;
	}
}

public CAT(Matrix_, TYPE) CAT(matrix_eye_, TYPE)(int size) {
	CAT(MatrixElem_, TYPE) p0, p1;
	
	p0 = p1 = new CAT(MatrixElem_, TYPE)(ONE);
	
	repeat (size - 1) {
		repeat (size) {
			p1 = p1.right = new CAT(MatrixElem_, TYPE)(ZERO);
		}
		
		p1 = p1.right = new CAT(MatrixElem_, TYPE)(ONE);
	}
	
	return new CAT(Matrix_, TYPE)(size, size, p0);
}

public CAT(Matrix_, TYPE) CAT(matrix_zeros_, TYPE)(int width, int height) {
	CAT(MatrixElem_, TYPE) p0, p1;
	
	p0 = p1 = new CAT(MatrixElem_, TYPE)(ZERO);
	
	repeat (width * height - 1) {
		p1 = p1.right = new CAT(MatrixElem_, TYPE)(ZERO);
	}
	
	return new CAT(Matrix_, TYPE)(width, height, p0);
}

extern void CAT(Library_Matrix_, TYPE)() {
}
