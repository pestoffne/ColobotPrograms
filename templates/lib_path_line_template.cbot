// Depends:
// lib_pathpart.cbot
// lib_affine_coordinate_system.cbot
#include <macro.cbot>

public class PathLine extends PathPart {
	public float from_x, from_y, to_x, to_y, max_progress;
	public AffineCoordinateSystem2D css, csi;
}

public void PathLine::PathLine(float from_x, float from_y, float to_x, float to_y) {
	this.from_x = from_x;
	this.from_y = from_y;
	this.to_x = to_x;
	this.to_y = to_y;
	this.max_progress = DISTANCE_2D(from_x, from_y, to_x, to_y);
	this.css = coordinate_system_from_2_points_2d(from_x, from_y, to_x, to_y);
	this.csi = css.inverse();
}

public point PathLine::from() {
	return new point(from_x, from_y);
}

public point PathLine::to() {
	return new point(to_x, to_y);
}

public float PathLine::length() {
	return DISTANCE_2D(from_x, from_y, to_x, to_y);
}

public float PathLine::time() {
	return DISTANCE_2D(from_x, from_y, to_x, to_y) / MAX_SPEED;
}

public float PathLine::get_progress(float px, float py) {
	return this.css._(px, py).x;
}

public float PathLine::get_progress(point pos) {
	return this.css._(pos).x;
}

public float PathLine::max_progress() {
	return this.max_progress;
}

public point PathLine::get_position(float progress) {
	return this.csi._(progress, 0);
}

public void PathLine::go(EBoost e) {
	nan * 0;  // Not implemented
}

public bool eq(PathLine a, PathLine b) {
	return a.from_x == b.from_x
	and a.from_y == b.from_y
	and a.to_x == b.to_x
	and a.to_y == b.to_y;
}

public bool almost_equal(PathLine a, PathLine b) {
	return abs(a.from_x - b.from_x) < EPS
	and abs(a.from_y - b.from_y) < EPS
	and abs(a.to_x - b.to_x) < EPS
	and abs(a.to_y - b.to_y) < EPS;
}

public string PathLine::to_str() {
#if 1
	return "PathLine(from_x=" + ROUND_2(from_x) + ", from_y=" + ROUND_2(from_y)
	+ ", to_x=" + ROUND_2(to_x) + ", to_y=" + ROUND_2(to_y)
	+ ", length=" + ROUND_2(length()) + ", time=" + ROUND_2(time()) + ")";
#else
        return "cv2.line(img,(" + round(from_x * 10) + "," + round(1000 - from_y * 10)
        + "),(" + round(to_x * 10) + "," + round(1000 - to_y * 10) + "), 2)";
#endif
}

public PathLine tangent_line(PathNode c1, PathNode c2) {
	AffineCoordinateSystem2D cs; point p1, p2; float dist, pm, mp, from_x, from_y, to_x, to_y;
	
	dist = DISTANCE_2D(c1.center_x, c1.center_y, c2.center_x, c2.center_y);
	
	// assume dist is non-zero
	from_x = (pow(c1.radius, 2) - c1.radius * c2.radius) / dist;
	from_y = sqrt(pow(c1.radius, 2) - pow(from_x, 2)) * SIGN(c1.radius);
	to_x = (pow(dist, 2) + c1.radius * c2.radius - pow(c2.radius, 2)) / dist;
	to_y = sqrt(pow(c2.radius, 2) - pow(to_x - dist, 2)) * SIGN(c2.radius);
	
	cs = coordinate_system_from_2_points_2d(c1.center_x, c1.center_y, c2.center_x, c2.center_y);
	p1 = cs._(from_x, from_y);
	p2 = cs._(to_x, to_y);
	return new PathLine(p1.x, p1.y, p2.x, p2.y);
}
